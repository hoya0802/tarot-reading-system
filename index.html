<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”® íƒ€ë¡œ ë¦¬ë”© ì‹œìŠ¤í…œ</title>
    
    <!-- CSS íŒŒì¼ -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/tarot.css">
    
    <!-- Vue.js -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ”®</text></svg>">
    
    <!-- ë””ë²„ê¹…ìš© ìŠ¤íƒ€ì¼ -->
    <style>
        .debug-info {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px;
            border: 1px solid #ccc;
            font-family: monospace;
            font-size: 12px;
        }
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            margin: 10px;
            border: 1px solid #ef5350;
        }
        .success {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 10px;
            margin: 10px;
            border: 1px solid #66bb6a;
        }
    </style>
</head>
<body>
    <!-- ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ -->
    <div class="debug-info">
        <h3>ğŸ”® íƒ€ë¡œ ë¦¬ë”© ì‹œìŠ¤í…œ - ê¸°ë³¸ í…ŒìŠ¤íŠ¸</h3>
        <p>ì´ í˜ì´ì§€ê°€ ë³´ì¸ë‹¤ë©´ ê¸°ë³¸ HTMLì€ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤.</p>
        <p>í˜„ì¬ ì‹œê°„: <span id="current-time"></span></p>
        <p>Vue.js ë¡œë”© ìƒíƒœ: <span id="vue-status">í™•ì¸ ì¤‘...</span></p>
        <p>CSS ë¡œë”© ìƒíƒœ: <span id="css-status">í™•ì¸ ì¤‘...</span></p>
    </div>

    <div id="app">
        <!-- ë¡œë”© í™”ë©´ -->
        <div v-if="isLoading" class="loading-screen">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <h2>íƒ€ë¡œ ë¦¬ë”© ì‹œìŠ¤í…œ ë¡œë”© ì¤‘...</h2>
                <p>{{ loadingMessage }}</p>
            </div>
        </div>

        <!-- ì„¤ì • ì•ˆë‚´ í™”ë©´ -->
        <div v-if="showSetupGuide" class="setup-guide">
            <div class="setup-content">
                <h1>ğŸ”® íƒ€ë¡œ ë¦¬ë”© ì‹œìŠ¤í…œ ì„¤ì •</h1>
                <div class="setup-steps">
                    <h3>ì„¤ì • ë‹¨ê³„:</h3>
                    <ol>
                        <li>Supabase í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ì„¸ìš”</li>
                        <li>ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆë¥¼ ì„¤ì •í•˜ì„¸ìš”</li>
                        <li>Supabase ì—°ê²° ì •ë³´ë¥¼ ì…ë ¥í•˜ì„¸ìš”</li>
                        <li>í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”</li>
                    </ol>
                </div>
                <div class="setup-help">
                    <h3>ë„ì›€ì´ í•„ìš”í•˜ì‹ ê°€ìš”?</h3>
                    <p>README.md íŒŒì¼ì„ ì°¸ê³ í•˜ì—¬ ì„¤ì •ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.</p>
                    <button @click="checkConnection" class="btn btn-primary">ì—°ê²° í™•ì¸</button>
                </div>
            </div>
        </div>

        <!-- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ -->
        <div v-if="!isLoading && !showSetupGuide" class="main-app">
            <!-- í—¤ë” -->
            <header class="app-header">
                <h1>ğŸ”® íƒ€ë¡œ ë¦¬ë”© ì‹œìŠ¤í…œ</h1>
                <p>ë‹¹ì‹ ì˜ ìš´ëª…ì„ ì¹´ë“œë¡œ ì½ì–´ë³´ì„¸ìš”</p>
            </header>

            <!-- ë©”ì¸ ì»¨í…ì¸  -->
            <main class="app-main">
                <!-- ëª©ì  ì„ íƒ -->
                <purpose-selector 
                    v-if="currentStep === 'purpose'"
                    @purpose-selected="onPurposeSelected">
                </purpose-selector>

                <!-- íƒ€ë¡œ ë± -->
                <tarot-deck 
                    v-if="currentStep === 'deck'"
                    :cards="cards"
                    @selection-complete="onCardSelectionComplete">
                </tarot-deck>

                <!-- ì¹´ë“œ ìŠ¤í”„ë ˆë“œ -->
                <card-spread 
                    v-if="currentStep === 'spread'"
                    :selectedCards="selectedCards"
                    @start-reading="onStartReading"
                    @reshuffle="onReshuffle">
                </card-spread>

                <!-- ë¦¬ë”© ê²°ê³¼ -->
                <reading-result 
                    v-if="currentStep === 'result'"
                    :readingData="readingData"
                    @new-reading="onNewReading">
                </reading-result>

                <!-- ì‚¬ìš©ì íˆìŠ¤í† ë¦¬ -->
                <user-history 
                    v-if="currentStep === 'history'"
                    @back-to-main="currentStep = 'purpose'">
                </user-history>
            </main>

            <!-- ë„¤ë¹„ê²Œì´ì…˜ -->
            <nav class="app-nav">
                <button @click="currentStep = 'purpose'" class="nav-btn">ğŸ  í™ˆ</button>
                <button @click="currentStep = 'history'" class="nav-btn">ğŸ“š íˆìŠ¤í† ë¦¬</button>
                <button @click="showConnectionStatus" class="nav-btn">ğŸ”— ì—°ê²° ìƒíƒœ</button>
            </nav>
        </div>
    </div>

    <!-- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ -->
    <script type="module">
        import supabase, { checkSupabaseConnection, showSetupGuide, simpleConnectionTest } from './js/services/supabase.js';
        import { loadCards, tarotService } from './js/services/tarotService.js';

        const { createApp } = Vue;

        // Vue ì»´í¬ë„ŒíŠ¸ë“¤ ì •ì˜
        const PurposeSelector = {
            props: ['selectedPurpose'],
            data() {
                return {
                    purposes: [
                        { code: 'love', name: 'ì—°ì• /ì‚¬ë‘', icon: 'ğŸ’•', color: '#ff6b6b', description: 'ì‚¬ë‘ê³¼ ê´€ê³„ì— ê´€í•œ í•´ì„' },
                        { code: 'career', name: 'ì§ì¥/ì¼', icon: 'ğŸ’¼', color: '#4ecdc4', description: 'ì§ì¥ê³¼ ì—…ë¬´ì— ê´€í•œ í•´ì„' },
                        { code: 'daily', name: 'ì˜¤ëŠ˜ì˜ ìš´ì„¸', icon: 'â˜€ï¸', color: '#45b7d1', description: 'ì˜¤ëŠ˜ í•˜ë£¨ì˜ ì „ë°˜ì ì¸ ìš´ì„¸' },
                        { code: 'health', name: 'ê±´ê°•', icon: 'ğŸŒ¿', color: '#96ceb4', description: 'ê±´ê°•ê³¼ ì›°ë¹™ì— ê´€í•œ í•´ì„' },
                        { code: 'money', name: 'ê¸ˆì „', icon: 'ğŸ’°', color: '#feca57', description: 'ì¬ì •ê³¼ ëˆì— ê´€í•œ í•´ì„' }
                    ]
                };
            },
            template: `
                <div class="section purpose-selector">
                    <h2>ğŸ”® ë¦¬ë”© ëª©ì ì„ ì„ íƒí•˜ì„¸ìš”</h2>
                    <p class="text-center mb-3">ì–´ë–¤ ë¶„ì•¼ì— ëŒ€í•´ ê¶ê¸ˆí•œê°€ìš”?</p>
                    
                    <div class="purpose-grid">
                        <div 
                            v-for="purpose in purposes" 
                            :key="purpose.code"
                            class="purpose-item"
                            :class="{ 'selected': selectedPurpose === purpose.code }"
                            :style="{ borderColor: purpose.color }"
                            @click="$emit('purpose-selected', purpose.code)">
                            
                            <div class="purpose-icon">{{ purpose.icon }}</div>
                            <div class="purpose-name">{{ purpose.name }}</div>
                            <div class="purpose-description">{{ purpose.description }}</div>
                            
                            <div v-if="selectedPurpose === purpose.code" class="selected-indicator">
                                âœ“ ì„ íƒë¨
                            </div>
                        </div>
                    </div>
                </div>
            `
        };

        const TarotDeck = {
            props: ['cards'],
            data() {
                return {
                    selectedCards: [],
                    currentFilter: 'all',
                    searchTerm: '',
                    sortBy: 'id'
                };
            },
            computed: {
                filteredCards() {
                    let cards = this.cards || [];
                    
                    // í•„í„°ë§ (ê°„ë‹¨í•œ ë²„ì „)
                    if (this.currentFilter !== 'all') {
                        cards = cards.filter(card => {
                            if (this.currentFilter === 'major') return card.major_minor === 'major';
                            if (this.currentFilter === 'minor') return card.major_minor === 'minor';
                            return card.suit === this.currentFilter;
                        });
                    }
                    
                    // ê²€ìƒ‰
                    if (this.searchTerm) {
                        const term = this.searchTerm.toLowerCase();
                        cards = cards.filter(card => 
                            card.name.toLowerCase().includes(term) ||
                            (card.keywords && card.keywords.toLowerCase().includes(term))
                        );
                    }
                    
                    // ì •ë ¬
                    cards = cards.sort((a, b) => {
                        if (this.sortBy === 'name') return a.name.localeCompare(b.name);
                        if (this.sortBy === 'type') {
                            if (a.major_minor !== b.major_minor) {
                                return a.major_minor === 'major' ? -1 : 1;
                            }
                            return a.id - b.id;
                        }
                        return a.id - b.id;
                    });
                    
                    return cards;
                }
            },
            template: `
                <div class="section tarot-deck">
                    <h2>ğŸƒ íƒ€ë¡œ ì¹´ë“œ ì„ íƒ</h2>
                    <p class="text-center mb-3">3ì¥ì˜ ì¹´ë“œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš” ({{ selectedCards.length }}/3)</p>
                    
                    <!-- í•„í„° ë° ê²€ìƒ‰ -->
                    <div class="deck-controls">
                        <div class="filter-section">
                            <select v-model="currentFilter" class="filter-select">
                                <option value="all">ì „ì²´</option>
                                <option value="major">ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜</option>
                                <option value="minor">ë§ˆì´ë„ˆ ì•„ë¥´ì¹´ë‚˜</option>
                                <option value="wands">ì™„ë“œ</option>
                                <option value="cups">ì»µ</option>
                                <option value="swords">ê²€</option>
                                <option value="pentacles">íœíƒ€í´</option>
                            </select>
                        </div>
                        
                        <div class="search-section">
                            <input 
                                type="text" 
                                v-model="searchTerm"
                                placeholder="ì¹´ë“œ ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰..."
                                class="search-input">
                        </div>
                    </div>
                    
                    <!-- ì„ íƒëœ ì¹´ë“œ í‘œì‹œ -->
                    <div v-if="selectedCards.length > 0" class="selected-cards-display">
                        <h4>ì„ íƒëœ ì¹´ë“œ</h4>
                        <div class="selected-cards-grid">
                            <div 
                                v-for="(card, index) in selectedCards" 
                                :key="card.id"
                                class="selected-card-item">
                                <div class="card-name">{{ card.name }}</div>
                                <button @click="removeCard(index)" class="remove-btn">ì œê±°</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ì¹´ë“œ ê·¸ë¦¬ë“œ -->
                    <div class="cards-container">
                        <div class="cards-grid">
                            <div 
                                v-for="card in filteredCards" 
                                :key="card.id"
                                class="tarot-card"
                                :class="{ 'selected': selectedCards.find(c => c.id === card.id) }"
                                @click="selectCard(card)">
                                
                                <div class="card-name">{{ card.name }}</div>
                                <div class="card-type">{{ card.major_minor === 'major' ? 'ë©”ì´ì €' : 'ë§ˆì´ë„ˆ' }}</div>
                                
                                <div v-if="selectedCards.find(c => c.id === card.id)" class="selected-indicator">
                                    âœ“ ì„ íƒë¨
                                </div>
                            </div>
                        </div>
                        
                        <div v-if="filteredCards.length === 0" class="no-cards">
                            <p>ê²€ìƒ‰ ì¡°ê±´ì— ë§ëŠ” ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤.</p>
                        </div>
                    </div>
                    
                    <!-- ì„ íƒ ì™„ë£Œ ë²„íŠ¼ -->
                    <div v-if="selectedCards.length === 3" class="selection-complete">
                        <button @click="completeSelection" class="btn btn-secondary">
                            ì¹´ë“œ ì„ íƒ ì™„ë£Œ (3/3)
                        </button>
                    </div>
                </div>
            `,
            methods: {
                selectCard(card) {
                    if (this.selectedCards.length >= 3) {
                        alert('ì´ë¯¸ 3ì¥ì˜ ì¹´ë“œë¥¼ ì„ íƒí–ˆìŠµë‹ˆë‹¤.');
                        return;
                    }
                    
                    if (this.selectedCards.find(c => c.id === card.id)) {
                        alert('ì´ë¯¸ ì„ íƒëœ ì¹´ë“œì…ë‹ˆë‹¤.');
                        return;
                    }
                    
                    this.selectedCards.push({
                        ...card,
                        reversed: Math.random() > 0.5 // ëœë¤ ì—­ë°©í–¥
                    });
                },
                
                removeCard(index) {
                    this.selectedCards.splice(index, 1);
                },
                
                completeSelection() {
                    if (this.selectedCards.length === 3) {
                        this.$emit('selection-complete', this.selectedCards);
                    }
                }
            }
        };

        const CardSpread = {
            props: ['selectedCards'],
            mounted() {
                console.log('CardSpread ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ë¨');
                console.log('selectedCards props:', this.selectedCards);
            },
            template: `
                <div class="section card-spread">
                    <h2>ğŸ´ ì„ íƒëœ ì¹´ë“œ ìŠ¤í”„ë ˆë“œ</h2>
                    <p class="text-center mb-3">ì„ íƒëœ 3ì¥ì˜ ì¹´ë“œë¥¼ í™•ì¸í•˜ê³  ë¦¬ë”©ì„ ì‹œì‘í•˜ì„¸ìš”</p>
                    
                    <!-- ë””ë²„ê¹… ì •ë³´ -->
                    <div style="background: #f0f0f0; padding: 10px; margin: 10px; border: 1px solid #ccc; font-family: monospace; font-size: 12px;">
                        <p><strong>ë””ë²„ê¹… ì •ë³´:</strong></p>
                        <p>selectedCards íƒ€ì…: {{ typeof selectedCards }}</p>
                        <p>selectedCards ê¸¸ì´: {{ selectedCards ? selectedCards.length : 'undefined' }}</p>
                        <p>selectedCards ë‚´ìš©: {{ JSON.stringify(selectedCards, null, 2) }}</p>
                    </div>
                    
                    <div class="spread-container">
                        <div class="spread-layout">
                                                         <div class="card-position past">
                                <h4>ê³¼ê±°</h4>
                                <div class="card-display">
                                    <div class="card-name">{{ getCardName(0) }}</div>
                                    <div class="card-direction">{{ getCardDirection(0) }}</div>
                                </div>
                            </div>
                            
                            <div class="card-position present">
                                <h4>í˜„ì¬</h4>
                                <div class="card-display">
                                    <div class="card-name">{{ getCardName(1) }}</div>
                                    <div class="card-direction">{{ getCardDirection(1) }}</div>
                                </div>
                            </div>
                            
                            <div class="card-position future">
                                <h4>ë¯¸ë˜</h4>
                                <div class="card-display">
                                    <div class="card-name">{{ getCardName(2) }}</div>
                                    <div class="card-direction">{{ getCardDirection(2) }}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="spread-actions">
                        <button @click="startReading" class="btn btn-primary">
                            ğŸ”® ë¦¬ë”© ì‹œì‘
                        </button>
                        <button @click="$emit('reshuffle')" class="btn btn-secondary">
                            ğŸ”„ ë‹¤ì‹œ ì„ê¸°
                        </button>
                    </div>
                </div>
            `,
            methods: {
                getCardName(index) {
                    console.log(`getCardName(${index}) í˜¸ì¶œë¨`);
                    console.log('this.selectedCards:', this.selectedCards);
                    
                    if (!this.selectedCards || !Array.isArray(this.selectedCards) || !this.selectedCards[index]) {
                        console.log(`ì¹´ë“œ ${index} ì—†ìŒ`);
                        return 'ì¹´ë“œ ì—†ìŒ';
                    }
                    
                    const cardName = this.selectedCards[index].name || 'ì¹´ë“œ ì—†ìŒ';
                    console.log(`ì¹´ë“œ ${index} ì´ë¦„:`, cardName);
                    return cardName;
                },
                getCardDirection(index) {
                    console.log(`getCardDirection(${index}) í˜¸ì¶œë¨`);
                    
                    if (!this.selectedCards || !Array.isArray(this.selectedCards) || !this.selectedCards[index]) {
                        return 'ì •ë°©í–¥';
                    }
                    
                    const direction = this.selectedCards[index].reversed ? 'ì—­ë°©í–¥' : 'ì •ë°©í–¥';
                    console.log(`ì¹´ë“œ ${index} ë°©í–¥:`, direction);
                    return direction;
                },
                startReading() {
                    console.log('CardSpreadì—ì„œ ë¦¬ë”© ì‹œì‘ í˜¸ì¶œë¨');
                    console.log('this.selectedCards:', this.selectedCards);
                    console.log('this.selectedCards íƒ€ì…:', typeof this.selectedCards);
                    console.log('this.selectedCards ê¸¸ì´:', this.selectedCards ? this.selectedCards.length : 'undefined');
                    
                    if (!this.selectedCards || !Array.isArray(this.selectedCards) || this.selectedCards.length === 0) {
                        console.error('CardSpread: ì„ íƒëœ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤!');
                        alert('ì„ íƒëœ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤. ì¹´ë“œë¥¼ ë‹¤ì‹œ ì„ íƒí•´ì£¼ì„¸ìš”.');
                        return;
                    }
                    
                    console.log('CardSpreadì—ì„œ ì´ë²¤íŠ¸ ë°œìƒ:', this.selectedCards);
                    this.$emit('start-reading', this.selectedCards);
                }
            }
        };

        const ReadingResult = {
            props: ['readingData'],
            template: `
                <div class="section reading-result">
                    <h2>âœ¨ íƒ€ë¡œ ë¦¬ë”© ê²°ê³¼</h2>
                    
                    <div v-if="readingData" class="result-content">
                        <div class="result-summary">
                            <h3>ğŸ“‹ ë¦¬ë”© ìš”ì•½</h3>
                            <p><strong>ëª©ì :</strong> {{ getPurposeName(readingData.purpose) }}</p>
                            <p><strong>ë¦¬ë”© ì‹œê°„:</strong> {{ formatDate(readingData.timestamp) }}</p>
                        </div>
                        
                        <div class="cards-summary">
                            <h3>ğŸ´ ì„ íƒëœ ì¹´ë“œ</h3>
                            <div class="selected-cards-summary">
                                <div v-for="(card, index) in getSafeCards()" :key="card.id" class="card-summary">
                                    <div class="position">{{ getPositionName(index) }}</div>
                                    <div class="card-info">
                                        <div class="card-name">{{ card.name || 'ì¹´ë“œ ì—†ìŒ' }}</div>
                                        <div class="card-direction">{{ card.reversed ? 'ì—­ë°©í–¥' : 'ì •ë°©í–¥' }}</div>
                                        <div class="card-meaning">{{ getCardMeaning(card, index) }}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="reading-interpretation">
                            <h3>ğŸ”® í•´ì„</h3>
                            <div class="interpretation-content">
                                <p><strong>ì „ì²´ì ì¸ ì˜ë¯¸:</strong></p>
                                <p>{{ readingData.combination?.overall_meaning || 'ê¸°ë³¸ì ì¸ í•´ì„ì´ ì œê³µë©ë‹ˆë‹¤.' }}</p>
                                
                                <p><strong>ì¡°ì–¸:</strong></p>
                                <p>{{ readingData.combination?.advice || 'í˜„ì¬ ìƒí™©ì„ ì˜ ê´€ì°°í•˜ê³  ë¯¸ë˜ë¥¼ ì¤€ë¹„í•˜ì„¸ìš”.' }}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="result-actions">
                        <button @click="$emit('new-reading')" class="btn btn-primary">
                            ğŸ†• ìƒˆë¡œìš´ ë¦¬ë”©
                        </button>
                    </div>
                </div>
            `,
            methods: {
                getPurposeName(purpose) {
                    const purposes = {
                        'love': 'ì—°ì• /ì‚¬ë‘',
                        'career': 'ì§ì¥/ì¼',
                        'daily': 'ì˜¤ëŠ˜ì˜ ìš´ì„¸',
                        'health': 'ê±´ê°•',
                        'money': 'ê¸ˆì „'
                    };
                    return purposes[purpose] || purpose;
                },
                formatDate(timestamp) {
                    return new Date(timestamp).toLocaleString('ko-KR');
                },
                getPositionName(index) {
                    const positions = ['ê³¼ê±°', 'í˜„ì¬', 'ë¯¸ë˜'];
                    return positions[index] || '';
                },
                getSafeCards() {
                    if (!this.readingData || !this.readingData.cards || !Array.isArray(this.readingData.cards)) {
                        return [];
                    }
                    return this.readingData.cards;
                },
                getCardMeaning(card, index) {
                    if (!this.readingData || !this.readingData.cardMeanings || !this.readingData.cardMeanings[index]) {
                        return 'ì˜ë¯¸ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                    }
                    
                    const meaning = this.readingData.cardMeanings[index];
                    if (!meaning.meaning) {
                        return 'ì˜ë¯¸ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
                    }
                    
                    // ì˜ë¯¸ í…ìŠ¤íŠ¸ë¥¼ ì§§ê²Œ ìë¥´ê¸°
                    return meaning.meaning.length > 100 ? 
                           meaning.meaning.substring(0, 100) + '...' : 
                           meaning.meaning;
                }
            }
        };

        const UserHistory = {
            template: `
                <div class="section user-history">
                    <h2>ğŸ“š ë¦¬ë”© íˆìŠ¤í† ë¦¬</h2>
                    <p class="text-center mb-3">ì´ì „ ë¦¬ë”© ê¸°ë¡ì„ í™•ì¸í•˜ì„¸ìš”</p>
                    
                    <div class="history-content">
                        <p>íˆìŠ¤í† ë¦¬ ê¸°ëŠ¥ì€ ë¡œê·¸ì¸ í›„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                        <button @click="$emit('back-to-main')" class="btn btn-secondary">
                            â† ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                        </button>
                    </div>
                </div>
            `
        };

        // ê¸°ë³¸ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë“¤
        function updateCurrentTime() {
            document.getElementById('current-time').textContent = new Date().toLocaleString();
        }

        function checkVueStatus() {
            if (typeof Vue !== 'undefined') {
                document.getElementById('vue-status').textContent = 'âœ… ë¡œë“œë¨';
                document.getElementById('vue-status').className = 'success';
            } else {
                document.getElementById('vue-status').textContent = 'âŒ ë¡œë“œ ì‹¤íŒ¨';
                document.getElementById('vue-status').className = 'error';
            }
        }

        function checkCSSStatus() {
            const styleSheets = document.styleSheets;
            let cssLoaded = false;
            
            for (let i = 0; i < styleSheets.length; i++) {
                try {
                    if (styleSheets[i].href && styleSheets[i].href.includes('style.css')) {
                        cssLoaded = true;
                        break;
                    }
                } catch (e) {
                    // CORS ì˜¤ë¥˜ ë¬´ì‹œ
                }
            }
            
            if (cssLoaded) {
                document.getElementById('css-status').textContent = 'âœ… ë¡œë“œë¨';
                document.getElementById('css-status').className = 'success';
            } else {
                document.getElementById('css-status').textContent = 'âŒ ë¡œë“œ ì‹¤íŒ¨';
                document.getElementById('css-status').className = 'error';
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        window.addEventListener('load', function() {
            updateCurrentTime();
            checkVueStatus();
            checkCSSStatus();
            
            // 1ì´ˆë§ˆë‹¤ ì‹œê°„ ì—…ë°ì´íŠ¸
            setInterval(updateCurrentTime, 1000);
        });

        const app = createApp({
            data() {
                return {
                    isLoading: true,
                    showSetupGuide: false,
                    currentStep: 'purpose',
                    selectedPurpose: null,
                    cards: [],
                    selectedCards: [],
                    readingData: null,
                    loadingMessage: 'ì‹œìŠ¤í…œì„ ì´ˆê¸°í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤...'
                };
            },
            async mounted() {
                await this.initializeApp();
            },
            methods: {
                async initializeApp() {
                    try {
                        this.loadingMessage = 'Supabase ì—°ê²°ì„ í™•ì¸í•˜ê³  ìˆìŠµë‹ˆë‹¤...';
                        
                        // Supabase ì—°ê²° í™•ì¸
                        await checkSupabaseConnection();
                        
                        this.loadingMessage = 'ì¹´ë“œ ë°ì´í„°ë¥¼ ë¡œë”©í•˜ê³  ìˆìŠµë‹ˆë‹¤...';
                        
                        // ì¹´ë“œ ë°ì´í„° ë¡œë“œ
                        this.cards = await loadCards();
                        
                        this.isLoading = false;
                        console.log('ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì™„ë£Œ');
                        
                    } catch (error) {
                        console.error('ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                        this.showSetupGuide = true;
                        this.isLoading = false;
                        showSetupGuide();
                    }
                },
                
                onPurposeSelected(purpose) {
                    this.selectedPurpose = purpose;
                    this.currentStep = 'deck';
                },
                
                onCardSelectionComplete(cards) {
                    console.log('=== onCardSelectionComplete í˜¸ì¶œë¨ ===');
                    console.log('ì „ë‹¬ë°›ì€ cards:', cards);
                    console.log('cards íƒ€ì…:', typeof cards);
                    console.log('cards ê¸¸ì´:', cards ? cards.length : 'undefined');
                    console.log('cards ë‚´ìš©:', JSON.stringify(cards, null, 2));
                    
                    this.selectedCards = cards;
                    console.log('this.selectedCards ì„¤ì •ë¨:', this.selectedCards);
                    console.log('this.selectedCards íƒ€ì…:', typeof this.selectedCards);
                    console.log('this.selectedCards ê¸¸ì´:', this.selectedCards ? this.selectedCards.length : 'undefined');
                    
                    this.currentStep = 'spread';
                    console.log('currentStepì„ spreadë¡œ ë³€ê²½');
                    console.log('=== onCardSelectionComplete ì™„ë£Œ ===');
                },
                
                async onStartReading(cards) {
                    try {
                        this.isLoading = true;
                        
                        console.log('ë¦¬ë”© ì‹œì‘ - ì„ íƒëœ ì¹´ë“œë“¤:', cards);
                        console.log('ì„ íƒëœ ëª©ì :', this.selectedPurpose);
                        console.log('this.selectedCards:', this.selectedCards);
                        
                        // cardsê°€ undefinedì¸ ê²½ìš° this.selectedCards ì‚¬ìš©
                        let selectedCards = cards;
                        
                        if (!selectedCards || !Array.isArray(selectedCards) || selectedCards.length === 0) {
                            console.log('cards ë§¤ê°œë³€ìˆ˜ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ, this.selectedCards ì‚¬ìš©');
                            selectedCards = this.selectedCards;
                        }
                        
                        if (!selectedCards || !Array.isArray(selectedCards) || selectedCards.length === 0) {
                            throw new Error('ì„ íƒëœ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤. ì¹´ë“œë¥¼ ë‹¤ì‹œ ì„ íƒí•´ì£¼ì„¸ìš”.');
                        }
                        
                        console.log('ìµœì¢… ì‚¬ìš©í•  ì¹´ë“œë“¤:', selectedCards);
                        
                        // ì„ íƒëœ ì¹´ë“œë“¤ì˜ ì‹¤ì œ ì˜ë¯¸ë¥¼ ë¶„ì„
                        const cardMeanings = selectedCards.map((card, index) => {
                            console.log(`ì¹´ë“œ ${index + 1}:`, card);
                            
                            const meaning = {
                                name: card.name,
                                position: ['ê³¼ê±°', 'í˜„ì¬', 'ë¯¸ë˜'][index] || 'ê³¼ê±°',
                                meaning: card.reversed ? card.reversed_meaning : card.upright_meaning,
                                keywords: card.keywords,
                                isReversed: card.reversed
                            };
                            
                            console.log(`ì¹´ë“œ ${index + 1} ì˜ë¯¸:`, meaning);
                            return meaning;
                        });
                        
                        console.log('ì¹´ë“œ ì˜ë¯¸ ë¶„ì„ ì™„ë£Œ:', cardMeanings);
                        
                        // ì „ì²´ì ì¸ í•´ì„ ìƒì„±
                        const overallMeaning = this.generateOverallMeaning(cardMeanings, this.selectedPurpose);
                        const advice = this.generateAdvice(cardMeanings, this.selectedPurpose);
                        
                        console.log('ìƒì„±ëœ í•´ì„:', { overallMeaning, advice });
                        
                        // ë¦¬ë”© ê²°ê³¼ ìƒì„±
                        this.readingData = {
                            cards: cards,
                            purpose: this.selectedPurpose,
                            cardMeanings: cardMeanings,
                            combination: {
                                overall_meaning: overallMeaning,
                                advice: advice
                            },
                            timestamp: new Date()
                        };
                        
                        console.log('ë¦¬ë”© ë°ì´í„° ìƒì„± ì™„ë£Œ:', this.readingData);
                        
                        this.currentStep = 'result';
                    } catch (error) {
                        console.error('ë¦¬ë”© ìƒì„± ì‹¤íŒ¨:', error);
                        console.error('ì˜¤ë¥˜ ìŠ¤íƒ:', error.stack);
                        console.error('ì˜¤ë¥˜ ë©”ì‹œì§€:', error.message);
                        alert(`ë¦¬ë”©ì„ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                onReshuffle() {
                    this.selectedCards = [];
                    this.currentStep = 'deck';
                },
                
                onNewReading() {
                    this.selectedPurpose = null;
                    this.selectedCards = [];
                    this.readingData = null;
                    this.currentStep = 'purpose';
                },
                
                async checkConnection() {
                    try {
                        console.log('ì—°ê²° í™•ì¸ ë²„íŠ¼ í´ë¦­ë¨');
                        
                        // ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ë¨¼ì € ì‹¤í–‰
                        const simpleTest = await simpleConnectionTest();
                        if (simpleTest) {
                            alert('ì—°ê²°ì´ ì„±ê³µí–ˆìŠµë‹ˆë‹¤!');
                            this.showSetupGuide = false;
                            await this.initializeApp();
                        } else {
                            alert('ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                        }
                    } catch (error) {
                        console.error('ì—°ê²° í™•ì¸ ì¤‘ ì˜¤ë¥˜:', error);
                        alert(`ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${error.message}`);
                    }
                },
                
                showConnectionStatus() {
                    const status = this.isLoading ? 'ë¡œë”© ì¤‘' : 
                                 this.showSetupGuide ? 'ì„¤ì • í•„ìš”' : 'ì—°ê²°ë¨';
                    alert(`í˜„ì¬ ìƒíƒœ: ${status}`);
                },
                
                generateOverallMeaning(cardMeanings, purpose) {
                    try {
                        console.log('generateOverallMeaning í˜¸ì¶œ:', { cardMeanings, purpose });
                        
                        const purposeNames = {
                            'love': 'ì‚¬ë‘ê³¼ ê´€ê³„',
                            'career': 'ì§ì¥ê³¼ ì—…ë¬´',
                            'daily': 'ì˜¤ëŠ˜ì˜ ìš´ì„¸',
                            'health': 'ê±´ê°•ê³¼ ì›°ë¹™',
                            'money': 'ì¬ì •ê³¼ ëˆ'
                        };
                        
                        const purposeName = purposeNames[purpose] || 'ì¼ë°˜ì ì¸';
                        
                        // ì•ˆì „í•œ ì¹´ë“œ ì´ë¦„ ì¶”ì¶œ
                        const cardNames = cardMeanings.map(card => card?.name || 'ì•Œ ìˆ˜ ì—†ëŠ” ì¹´ë“œ');
                        
                        // ì¹´ë“œë“¤ì˜ í‚¤ì›Œë“œë¥¼ ë¶„ì„ (ì•ˆì „í•˜ê²Œ)
                        const keywords = cardMeanings
                            .map(card => card?.keywords)
                            .filter(k => k && typeof k === 'string')
                            .join(', ');
                        
                        const result = `${purposeName} ì¸¡ë©´ì—ì„œ ${cardNames[0]}, ${cardNames[1]}, ${cardNames[2]}ì˜ ì¡°í•©ì€ ${keywords || 'ë‹¤ì–‘í•œ'}ì˜ ì—ë„ˆì§€ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ê³¼ê±°ì˜ ê²½í—˜ì´ í˜„ì¬ì˜ ì„ íƒì— ì˜í–¥ì„ ë¯¸ì¹˜ê³ , ë¯¸ë˜ì˜ ë°©í–¥ì„±ì„ ì œì‹œí•˜ê³  ìˆìŠµë‹ˆë‹¤.`;
                        
                        console.log('generateOverallMeaning ê²°ê³¼:', result);
                        return result;
                    } catch (error) {
                        console.error('generateOverallMeaning ì˜¤ë¥˜:', error);
                        return 'ì¹´ë“œë“¤ì˜ ì¡°í•©ì„ í†µí•´ í˜„ì¬ ìƒí™©ì„ ë¶„ì„í•œ ê²°ê³¼, ê· í˜• ì¡íŒ ë°œì „ì˜ ì‹œê¸°ì…ë‹ˆë‹¤.';
                    }
                },
                
                generateAdvice(cardMeanings, purpose) {
                    try {
                        console.log('generateAdvice í˜¸ì¶œ:', { cardMeanings, purpose });
                        
                        const reversedCards = cardMeanings.filter(card => card?.isReversed);
                        const uprightCards = cardMeanings.filter(card => !card?.isReversed);
                        
                        console.log('ì—­ë°©í–¥ ì¹´ë“œ ìˆ˜:', reversedCards.length);
                        console.log('ì •ë°©í–¥ ì¹´ë“œ ìˆ˜:', uprightCards.length);
                        
                        let advice = '';
                        
                        if (reversedCards.length > 1) {
                            advice = 'ì—­ë°©í–¥ ì¹´ë“œê°€ ë§ì•„ í˜„ì¬ ì–´ë ¤ìš´ ì‹œê¸°ë¥¼ ê²ªê³  ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¸ë‚´ì‹¬ì„ ê°€ì§€ê³  ìƒí™©ì„ ê´€ì°°í•˜ì„¸ìš”.';
                        } else if (uprightCards.length > 1) {
                            advice = 'ì •ë°©í–¥ ì¹´ë“œê°€ ë§ì•„ ê¸ì •ì ì¸ ì—ë„ˆì§€ê°€ íë¥´ê³  ìˆìŠµë‹ˆë‹¤. ìì‹ ì˜ ì§ê°ì„ ë¯¿ê³  í–‰ë™í•˜ì„¸ìš”.';
                        } else {
                            advice = 'ê· í˜• ì¡íŒ ì¹´ë“œ ë°°ì¹˜ì…ë‹ˆë‹¤. í˜„ì¬ ìƒí™©ì„ ê°ê´€ì ìœ¼ë¡œ ë¶„ì„í•˜ê³  ì‹ ì¤‘í•˜ê²Œ íŒë‹¨í•˜ì„¸ìš”.';
                        }
                        
                        console.log('generateAdvice ê²°ê³¼:', advice);
                        return advice;
                    } catch (error) {
                        console.error('generateAdvice ì˜¤ë¥˜:', error);
                        return 'í˜„ì¬ ìƒí™©ì„ ì˜ ê´€ì°°í•˜ê³  ë¯¸ë˜ë¥¼ ì¤€ë¹„í•˜ì„¸ìš”.';
                    }
                }
            }
        });

        // ì»´í¬ë„ŒíŠ¸ ë“±ë¡
        app.component('purpose-selector', PurposeSelector);
        app.component('tarot-deck', TarotDeck);
        app.component('card-spread', CardSpread);
        app.component('reading-result', ReadingResult);
        app.component('user-history', UserHistory);

        // ì•± ë§ˆìš´íŠ¸
        app.mount('#app');
    </script>
</body>
</html>
