<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>타로 리딩 시스템 v0.1.5</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/tarot.css">
</head>
<body>
    <div id="app">
        <header class="header">
            <div class="container">
                <h1>🔮 타로 리딩 시스템 <span class="version">v0.1.5</span></h1>
                <p>당신의 운명을 읽어드립니다</p>
            </div>
        </header>

        <main class="main">
            <div class="container">
                <!-- 로딩 화면 -->
                <div id="loading" class="section loading" style="display: none;">
                    <div class="loading-spinner"></div>
                    <p>로딩 중...</p>
                </div>

                <!-- 설정 가이드 -->
                <div id="setup" class="section setup" style="display: none;">
                    <h2>🔧 설정이 필요합니다</h2>
                    <p>Supabase 연결을 확인해주세요.</p>
                    <div id="setupStatus">연결 상태 확인 중...</div>
                    <button onclick="testConnection()" class="btn btn-primary">연결 확인</button>
                </div>

                <!-- 생년월일 입력 -->
                <div id="birthDateInput" class="section birth-date-input">
                    <h2>📅 생년월일을 입력해주세요</h2>
                    <p class="text-center mb-4">더욱 개인화된 타로 리딩을 위해 생년월일을 입력해주세요</p>
                    
                    <div class="birth-date-form">
                        <div class="form-group">
                            <label for="birthYear">출생년도</label>
                            <select id="birthYear" class="form-control" required>
                                <option value="">년도 선택</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="birthMonth">출생월</label>
                            <select id="birthMonth" class="form-control" required>
                                <option value="">월 선택</option>
                                <option value="1">1월</option>
                                <option value="2">2월</option>
                                <option value="3">3월</option>
                                <option value="4">4월</option>
                                <option value="5">5월</option>
                                <option value="6">6월</option>
                                <option value="7">7월</option>
                                <option value="8">8월</option>
                                <option value="9">9월</option>
                                <option value="10">10월</option>
                                <option value="11">11월</option>
                                <option value="12">12월</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="birthDay">출생일</label>
                            <select id="birthDay" class="form-control" required>
                                <option value="">일 선택</option>
                            </select>
                        </div>
                        
                        <div class="form-actions">
                            <button id="confirmBirthDate" class="btn btn-primary" onclick="confirmBirthDate()">
                                ✅ 생년월일 확인
                            </button>
                            <button class="btn btn-secondary" onclick="skipBirthDate()">
                                ⏭️ 건너뛰기
                            </button>
                        </div>
                        
                        <div class="birth-date-info">
                            <p class="info-text">
                                💡 생년월일을 입력하시면 수치학적 관점을 바탕으로 더욱 개인화된 타로 해석을 제공해드립니다.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- 목적 선택 -->
                <div id="purpose" class="section purpose-selector" style="display: none;">
                    <h2>🎯 리딩 목적을 선택하세요</h2>
                    <div class="birth-date-summary" id="birthDateSummary" style="display: none;">
                        <p class="text-center mb-3">
                            📅 <span id="displayBirthDate"></span> | 
                            🔢 생명수: <span id="lifePathNumber"></span> | 
                            🌸 <span id="birthSeason"></span>
                        </p>
                    </div>
                    <div class="purpose-grid">
                        <button class="purpose-card" onclick="selectPurpose('love')">
                            <div class="purpose-icon">💕</div>
                            <h3>사랑과 관계</h3>
                            <p>연인, 가족, 친구와의 관계를 알아보세요</p>
                        </button>
                        <button class="purpose-card" onclick="selectPurpose('career')">
                            <div class="purpose-icon">💼</div>
                            <h3>직장과 업무</h3>
                            <p>커리어와 업무 상황을 점검해보세요</p>
                        </button>
                        <button class="purpose-card" onclick="selectPurpose('daily')">
                            <div class="purpose-icon">🌟</div>
                            <h3>오늘의 운세</h3>
                            <p>오늘 하루의 운세를 확인해보세요</p>
                        </button>
                        <button class="purpose-card" onclick="selectPurpose('health')">
                            <div class="purpose-icon">🏥</div>
                            <h3>건강과 웰빙</h3>
                            <p>건강과 웰빙 상태를 살펴보세요</p>
                        </button>
                        <button class="purpose-card" onclick="selectPurpose('money')">
                            <div class="purpose-icon">💰</div>
                            <h3>재정과 돈</h3>
                            <p>재정 상황과 투자를 점검해보세요</p>
                        </button>
                    </div>
                </div>

                <!-- 리딩 타입 선택 -->
                <div id="readingType" class="section reading-type-selector" style="display: none;">
                    <h2>🎴 리딩 방식을 선택하세요</h2>
                    <p class="text-center mb-4">선택하신 목적: <span id="selectedPurposeName" class="purpose-badge"></span></p>
                    
                    <div class="reading-type-grid">
                        <button class="reading-type-card" onclick="selectReadingType('single')">
                            <div class="type-icon">🎴</div>
                            <h3>한 장 리딩</h3>
                            <p>오늘의 핵심 메시지와 조언</p>
                            <div class="type-features">
                                <span class="feature">✨ 빠른 리딩</span>
                                <span class="feature">🎯 핵심 메시지</span>
                                <span class="feature">💡 즉시 조언</span>
                            </div>
                        </button>
                        
                        <button class="reading-type-card" onclick="selectReadingType('three')">
                            <div class="type-icon">🔮</div>
                            <h3>3장 스프레드</h3>
                            <p>과거-현재-미래의 흐름</p>
                            <div class="type-features">
                                <span class="feature">📖 상세 분석</span>
                                <span class="feature">⏰ 시간 흐름</span>
                                <span class="feature">🌟 종합 해석</span>
                            </div>
                        </button>
                    </div>
                    
                    <div class="text-center mt-4">
                        <button class="btn btn-secondary" onclick="goBackToPurpose()">
                            ← 목적 다시 선택
                        </button>
                    </div>
                </div>

                <!-- 한 장 카드 선택 -->
                <div id="singleDeck" class="section single-card-deck" style="display: none;">
                    <h2>🎴 한 장의 카드를 선택하세요</h2>
                    <p class="text-center mb-4">
                        목적: <span id="singlePurposeName" class="purpose-badge"></span> | 
                        리딩 타입: <span class="type-badge">한 장 리딩</span>
                    </p>
                    
                    <!-- 랜덤 선택 영역 -->
                    <div class="single-selection-area">
                        <div class="card-deck-visual">
                            <div class="deck-cards">
                                <div class="deck-card"></div>
                                <div class="deck-card"></div>
                                <div class="deck-card"></div>
                            </div>
                            <p>78장의 카드 중 하나를 선택하세요</p>
                        </div>
                        
                        <button id="singleRandomBtn" class="single-random-btn" onclick="selectSingleRandomCard()">
                            ✨ 운명의 카드 뽑기
                        </button>
                        
                        <button class="reset-btn" onclick="resetSingleSelection()">
                            🔄 다시 뽑기
                        </button>
                    </div>

                    <!-- 선택된 카드 표시 -->
                    <div id="singleCardDisplay" class="single-card-display" style="display: none;">
                        <h3>선택된 카드</h3>
                        <div id="singleSelectedCard" class="single-selected-card">
                            <!-- 선택된 카드가 여기에 표시됩니다 -->
                        </div>
                        <button id="singleCompleteBtn" class="single-complete" onclick="startSingleReading()">
                            ✨ 리딩 시작하기
                        </button>
                    </div>
                    
                    <div class="text-center mt-4">
                        <button class="btn btn-secondary" onclick="goBackToReadingType()">
                            ← 리딩 방식 다시 선택
                        </button>
                    </div>
                </div>

                <!-- 3장 카드 선택 -->
                <div id="deck" class="section tarot-deck" style="display: none;">
                    <h2>🎴 3장의 카드를 선택하세요</h2>
                    <p class="text-center mb-4">
                        목적: <span id="threePurposeName" class="purpose-badge"></span> | 
                        리딩 타입: <span class="type-badge">3장 스프레드</span>
                    </p>
                    
                    <!-- 랜덤 선택 영역 -->
                    <div class="random-selection-area">
                        <button id="randomSelectBtn" class="random-select-btn" onclick="selectRandomCard()">
                            🎲 카드 랜덤 선택
                        </button>
                        <button class="reset-btn" onclick="resetSelection()">
                            🔄 다시 시작
                        </button>
                    </div>

                    <!-- 선택된 카드 표시 -->
                    <div class="selected-cards-display">
                        <h3>선택된 카드 (<span id="selectedCount">0</span>/3)</h3>
                        <div id="selectedCardsList" class="selected-cards-list">
                            <!-- 선택된 카드들이 여기에 표시됩니다 -->
                        </div>
                        <button id="completeBtn" class="selection-complete" onclick="goToSpread()" style="display: none;">
                            🔮 리딩 시작하기
                        </button>
                    </div>
                    
                    <div class="text-center mt-4">
                        <button class="btn btn-secondary" onclick="goBackToReadingType()">
                            ← 리딩 방식 다시 선택
                        </button>
                    </div>
                </div>

                <!-- 카드 스프레드 -->
                <div id="spread" class="section card-spread" style="display: none;">
                    <h2>🎴 선택된 카드 스프레드</h2>
                    <p class="text-center mb-3">선택된 3장의 카드를 확인하고 리딩을 시작하세요</p>
                    
                    <!-- 디버깅 정보 -->
                    <div id="spreadDebug" class="debug-info">
                        <p><strong>스프레드 디버깅 정보:</strong></p>
                        <p>선택된 카드 수: <span id="debugCardCount">0</span></p>
                        <p>선택된 목적: <span id="debugPurpose">없음</span></p>
                    </div>
                    
                    <div class="spread-container">
                        <div class="spread-layout">
                            <div class="card-position">
                                <h4>과거</h4>
                                <div id="pastCard" class="card-summary">
                                    <h5 id="pastCardName">카드 선택 필요</h5>
                                    <p id="pastCardDirection" class="card-direction">-</p>
                                    <p id="pastCardMeaning" class="card-meaning">과거의 상황을 나타냅니다</p>
                                </div>
                            </div>
                            <div class="card-position">
                                <h4>현재</h4>
                                <div id="presentCard" class="card-summary">
                                    <h5 id="presentCardName">카드 선택 필요</h5>
                                    <p id="presentCardDirection" class="card-direction">-</p>
                                    <p id="presentCardMeaning" class="card-meaning">현재의 상황을 나타냅니다</p>
                                </div>
                            </div>
                            <div class="card-position">
                                <h4>미래</h4>
                                <div id="futureCard" class="card-summary">
                                    <h5 id="futureCardName">카드 선택 필요</h5>
                                    <p id="futureCardDirection" class="card-direction">-</p>
                                    <p id="futureCardMeaning" class="card-meaning">미래의 가능성을 나타냅니다</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="text-center mt-4">
                        <button class="btn btn-primary" onclick="startReading()">
                            ✨ 리딩 시작하기
                        </button>
                        <button class="btn btn-secondary" onclick="goToSelection()">
                            🔄 카드 다시 선택
                        </button>
                    </div>
                </div>

                <!-- 한 장 리딩 결과 -->
                <div id="singleResult" class="section single-reading-result" style="display: none;">
                    <h2>✨ 한 장 리딩 결과</h2>
                    
                    <div class="single-result-content">
                        <!-- 선택된 카드 표시 -->
                        <div class="single-result-card">
                            <div id="singleResultCardDisplay" class="single-card-large">
                                <!-- 카드 이미지가 여기에 표시됩니다 -->
                            </div>
                            <div class="single-card-info">
                                <h3 id="singleResultCardName">카드 이름</h3>
                                <p id="singleResultCardType" class="card-type">카드 타입</p>
                                <p id="singleResultCardDirection" class="card-direction">방향</p>
                            </div>
                        </div>

                        <!-- 핵심 메시지 -->
                        <div class="single-result-message">
                            <h3>🎯 핵심 메시지</h3>
                            <p id="singleCoreMeaning" class="core-meaning">핵심 메시지가 여기에 표시됩니다.</p>
                        </div>

                        <!-- 상세 해석 -->
                        <div class="single-result-sections">
                            <div class="single-section">
                                <h4>🔍 상세 해석</h4>
                                <p id="singleDetailedMeaning">상세 해석이 여기에 표시됩니다.</p>
                            </div>
                            
                            <div class="single-section">
                                <h4>🏷️ 키워드</h4>
                                <p id="singleKeywords" class="keywords">키워드가 여기에 표시됩니다.</p>
                            </div>
                            
                            <div class="single-section">
                                <h4 id="singleSpecialTitle">💡 특별 조언</h4>
                                <p id="singleSpecialInsight">목적별 특별 조언이 여기에 표시됩니다.</p>
                            </div>
                        </div>

                        <!-- 조언 -->
                        <div class="single-result-advice">
                            <h3>💡 오늘의 조언</h3>
                            <p id="singleAdvice" class="advice-text">조언이 여기에 표시됩니다.</p>
                        </div>

                        <!-- 액션 버튼 -->
                        <div class="single-result-actions">
                            <button class="btn btn-primary" onclick="startOver()">
                                🔄 새로운 리딩 시작
                            </button>
                            <button class="btn btn-secondary" onclick="goBackToSingleDeck()">
                                🎴 다른 카드 뽑기
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 3장 리딩 결과 -->
                <div id="result" class="section reading-result" style="display: none;">
                    <h2>✨ 3장 스프레드 리딩 결과</h2>
                    
                    <!-- 디버깅 정보 -->
                    <div id="resultDebug" class="debug-info">
                        <p><strong>결과 디버깅 정보:</strong></p>
                        <p>선택된 카드 수: <span id="resultDebugCardCount">0</span></p>
                        <p>선택된 목적: <span id="resultDebugPurpose">없음</span></p>
                        <p>카드 의미 수: <span id="resultDebugMeanings">0</span></p>
                    </div>

                    <div class="result-content">
                        <div class="result-summary">
                            <h3>🔮 전체적인 해석</h3>
                            <p id="overallMeaning">리딩 결과가 여기에 표시됩니다.</p>
                        </div>

                        <div class="result-advice">
                            <h3>💡 조언</h3>
                            <p id="advice">조언이 여기에 표시됩니다.</p>
                        </div>

                        <div class="result-cards">
                            <h3>📋 선택된 카드들</h3>
                            <div id="resultCardsList" class="cards-grid">
                                <!-- 선택된 카드들의 상세 정보가 여기에 표시됩니다 -->
                            </div>
                        </div>

                        <div class="text-center mt-4">
                            <button class="btn btn-primary" onclick="startOver()">
                                🔄 새로운 리딩 시작
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        // NumerologyService import
        import { NumerologyService } from './js/services/numerologyService.js';
        
        // === 버전 정보 ===
        const APP_VERSION = '0.1.5';
        
        // === 전역 변수들 ===
        let currentStep = 'birthDateInput';
        let selectedPurpose = null;
        let selectedReadingType = null; // 'single' 또는 'three'
        let selectedCards = [];
        let selectedSingleCard = null;
        let allCards = [];
        let readingData = null;
        let supabase = null;
        let userBirthDate = null; // 사용자 생년월일
        let lifePathNumber = null; // 생명수
        let birthSeason = null; // 출생 계절

        // === Supabase 설정 ===
        const SUPABASE_URL = 'https://qcubdynkiawpcmsflxfu.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFjdWJkeW5raWF3cGNtc2ZseGZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI0MDgxNzUsImV4cCI6MjA2Nzk4NDE3NX0.c2dFWAcMq62druoosEYY2JaT5FOL--7V9qjCTtPUzi0';

        // === Supabase 초기화 ===
        async function initializeSupabase() {
            try {
                console.log('Supabase 초기화 시작...');
                const { createClient } = await import('https://cdn.skypack.dev/@supabase/supabase-js');
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase 클라이언트 초기화 완료');
                return true;
            } catch (error) {
                console.error('Supabase 클라이언트 초기화 실패:', error);
                return false;
            }
        }

        // === 연결 테스트 ===
        async function simpleConnectionTest() {
            try {
                console.log('간단한 연결 테스트 시작...');
                
                if (!supabase) {
                    const initialized = await initializeSupabase();
                    if (!initialized) {
                        return false;
                    }
                }
                
                const { data, error } = await supabase
                    .from('tarot_cards')
                    .select('name')
                    .limit(1);
                
                if (error) {
                    console.error('간단한 테스트 실패:', error);
                    return false;
                }
                
                console.log('간단한 테스트 성공:', data);
                return true;
            } catch (error) {
                console.error('간단한 테스트 예외:', error);
                return false;
            }
        }

        // === 카드 데이터 가져오기 ===
        async function fetchCards() {
            try {
                console.log('카드 데이터 가져오기 시작...');
                
                if (!supabase) {
                    const initialized = await initializeSupabase();
                    if (!initialized) {
                        throw new Error('Supabase 초기화 실패');
                    }
                }

                const { data, error } = await supabase
                    .from('tarot_cards')
                    .select('*')
                    .order('id');
                
                if (error) throw error;
                
                // 카드에 그룹 정보 추가
                const cardsWithGroups = data.map(card => {
                    let groupId = null;
                    let groupName = null;
                    
                    if (card.major_minor === 'major') {
                        // 메이저 아르카나 그룹 매핑
                        const majorGroups = {
                            0: { id: 1, name: 'new_beginnings' },
                            1: { id: 1, name: 'new_beginnings' },
                            2: { id: 1, name: 'new_beginnings' },
                            6: { id: 2, name: 'relationships' },
                            11: { id: 2, name: 'relationships' },
                            14: { id: 2, name: 'relationships' },
                            13: { id: 3, name: 'transformation' },
                            16: { id: 3, name: 'transformation' },
                            20: { id: 3, name: 'transformation' },
                            3: { id: 4, name: 'material_world' },
                            4: { id: 4, name: 'material_world' },
                            5: { id: 4, name: 'material_world' },
                            7: { id: 5, name: 'spiritual_journey' },
                            8: { id: 5, name: 'spiritual_journey' },
                            9: { id: 5, name: 'spiritual_journey' },
                            10: { id: 6, name: 'completion' },
                            12: { id: 6, name: 'completion' },
                            15: { id: 6, name: 'completion' },
                            17: { id: 6, name: 'completion' },
                            18: { id: 6, name: 'completion' },
                            19: { id: 6, name: 'completion' },
                            21: { id: 6, name: 'completion' }
                        };
                        const group = majorGroups[card.id] || { id: 6, name: 'completion' };
                        groupId = group.id;
                        groupName = group.name;
                    } else {
                        // 마이너 아르카나 수트 매핑
                        const suitGroups = {
                            'wands': { id: 7, name: 'wands' },
                            'cups': { id: 8, name: 'cups' },
                            'swords': { id: 9, name: 'swords' },
                            'pentacles': { id: 10, name: 'pentacles' }
                        };
                        const group = suitGroups[card.suit] || { id: 7, name: 'wands' };
                        groupId = group.id;
                        groupName = group.name;
                    }
                    
                    return {
                        ...card,
                        groupId,
                        groupName,
                        displayName: formatCardName(card)
                    };
                });
                
                console.log('카드 데이터 로드 완료:', cardsWithGroups.length, '장');
                return cardsWithGroups;
            } catch (error) {
                console.error('카드 데이터 가져오기 실패:', error);
                throw error;
            }
        }

        // === 카드 이름 포맷팅 ===
        function formatCardName(card) {
            if (card.major_minor === 'major') {
                return card.name;
            } else {
                const numberNames = {
                    1: 'Ace', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five',
                    6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine', 10: 'Ten',
                    11: 'Page', 12: 'Knight', 13: 'Queen', 14: 'King'
                };
                const suitNames = {
                    'wands': 'Wands',
                    'cups': 'Cups', 
                    'swords': 'Swords',
                    'pentacles': 'Pentacles'
                };
                return `${numberNames[card.number]} of ${suitNames[card.suit]}`;
            }
        }

        // === 생년월일 관련 함수들 ===
        function initializeBirthDateForm() {
            // 년도 옵션 생성 (1950년 ~ 현재)
            const yearSelect = document.getElementById('birthYear');
            const currentYear = new Date().getFullYear();
            
            for (let year = currentYear; year >= 1950; year--) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year + '년';
                yearSelect.appendChild(option);
            }
            
            // 월 선택 시 일 옵션 업데이트
            document.getElementById('birthMonth').addEventListener('change', updateDayOptions);
            document.getElementById('birthYear').addEventListener('change', updateDayOptions);
        }
        
        // 전역 함수로 노출
        window.initializeBirthDateForm = initializeBirthDateForm;
        
        function updateDayOptions() {
            const year = document.getElementById('birthYear').value;
            const month = document.getElementById('birthMonth').value;
            const daySelect = document.getElementById('birthDay');
            
            // 기존 옵션 제거
            daySelect.innerHTML = '<option value="">일 선택</option>';
            
            if (year && month) {
                const daysInMonth = new Date(year, month, 0).getDate();
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const option = document.createElement('option');
                    option.value = day;
                    option.textContent = day + '일';
                    daySelect.appendChild(option);
                }
            }
        }
        
        // 전역 함수로 노출
        window.updateDayOptions = updateDayOptions;
        
        function confirmBirthDate() {
            const year = document.getElementById('birthYear').value;
            const month = document.getElementById('birthMonth').value;
            const day = document.getElementById('birthDay').value;
            
            if (!year || !month || !day) {
                alert('생년월일을 모두 선택해주세요.');
                return;
            }
            
            // 생년월일 저장
            userBirthDate = new Date(year, month - 1, day);
            
            // 생명수 계산
            lifePathNumber = calculateLifePathNumber(userBirthDate);
            
            // 출생 계절 계산
            birthSeason = getBirthSeason(userBirthDate);
            
            console.log('생년월일 확인:', {
                birthDate: userBirthDate,
                lifePathNumber: lifePathNumber,
                birthSeason: birthSeason
            });
            
            // 목적 선택 화면으로 이동
            showSection('purpose');
            
            // 생년월일 요약 표시
            displayBirthDateSummary();
        }
        
        // 전역 함수로 노출
        window.confirmBirthDate = confirmBirthDate;
        
        function skipBirthDate() {
            console.log('생년월일 입력 건너뛰기');
            showSection('purpose');
        }
        
        // 전역 함수로 노출
        window.skipBirthDate = skipBirthDate;
        
        function calculateLifePathNumber(birthDate) {
            const year = birthDate.getFullYear();
            const month = birthDate.getMonth() + 1;
            const day = birthDate.getDate();
            
            // 각 부분을 한 자리 숫자로 줄이기
            const yearSum = reduceToSingleDigit(year);
            const monthSum = reduceToSingleDigit(month);
            const daySum = reduceToSingleDigit(day);
            
            // 최종 생명수 계산
            const lifePathNumber = reduceToSingleDigit(yearSum + monthSum + daySum);
            
            return lifePathNumber;
        }
        
        function reduceToSingleDigit(number) {
            while (number > 9) {
                number = number.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
            }
            return number;
        }
        
        function getBirthSeason(birthDate) {
            const month = birthDate.getMonth() + 1;
            
            if (month >= 3 && month <= 5) return { name: '봄', emoji: '🌸' };
            if (month >= 6 && month <= 8) return { name: '여름', emoji: '☀️' };
            if (month >= 9 && month <= 11) return { name: '가을', emoji: '🍂' };
            return { name: '겨울', emoji: '❄️' };
        }
        
        function displayBirthDateSummary() {
            if (userBirthDate && lifePathNumber && birthSeason) {
                const birthDateStr = userBirthDate.toLocaleDateString('ko-KR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                document.getElementById('displayBirthDate').textContent = birthDateStr;
                document.getElementById('lifePathNumber').textContent = lifePathNumber;
                document.getElementById('birthSeason').textContent = `${birthSeason.emoji} ${birthSeason.name}`;
                
                document.getElementById('birthDateSummary').style.display = 'block';
            }
        }

        // === 초기화 ===
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('=== 애플리케이션 시작 ===');
            console.log('버전:', APP_VERSION);
            console.log('최근 업데이트: 계절 컨텍스트를 전체 조합 해석으로 이동');
            
            // 생년월일 폼 초기화
            initializeBirthDateForm();
            
            await initializeApp();
        });

        async function initializeApp() {
            try {
                showLoading(true);
                
                // Supabase 연결 테스트
                const isConnected = await simpleConnectionTest();
                if (!isConnected) {
                    showSection('setup');
                    return;
                }

                // 카드 데이터 로드
                const cards = await fetchCards();
                if (cards && cards.length > 0) {
                    allCards = cards;
                    console.log('카드 로드 완료:', allCards.length, '장');
                    showSection('birthDateInput');
                } else {
                    throw new Error('카드 데이터를 불러올 수 없습니다.');
                }
            } catch (error) {
                console.error('초기화 실패:', error);
                showSection('setup');
            } finally {
                showLoading(false);
            }
        }
        
        // 전역 함수로 노출
        window.initializeApp = initializeApp;

        // === 섹션 표시 함수 ===
        function showSection(sectionName) {
            console.log('섹션 변경:', currentStep, '→', sectionName);
            
            // 모든 섹션 숨기기
            const sections = ['loading', 'setup', 'birthDateInput', 'purpose', 'readingType', 'singleDeck', 'deck', 'spread', 'singleResult', 'result'];
            sections.forEach(section => {
                const element = document.getElementById(section);
                if (element) {
                    element.style.display = 'none';
                }
            });
            
            // 해당 섹션 표시
            const targetElement = document.getElementById(sectionName);
            if (targetElement) {
                targetElement.style.display = 'block';
            }
            currentStep = sectionName;
            
            console.log('현재 단계:', currentStep);
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        // 전역 함수로 노출
        window.showSection = showSection;
        window.showLoading = showLoading;

        // === 연결 테스트 ===
        async function testConnection() {
            try {
                console.log('연결 확인 버튼 클릭됨');
                document.getElementById('setupStatus').textContent = '연결 테스트 중...';
                
                const isConnected = await simpleConnectionTest();
                if (isConnected) {
                    document.getElementById('setupStatus').textContent = '연결 성공!';
                    alert('연결이 성공했습니다!');
                    await initializeApp();
                } else {
                    document.getElementById('setupStatus').textContent = '연결 실패';
                    alert('연결에 실패했습니다. 콘솔을 확인해주세요.');
                }
            } catch (error) {
                console.error('연결 확인 중 오류:', error);
                document.getElementById('setupStatus').textContent = `연결 오류: ${error.message}`;
                alert(`연결에 실패했습니다: ${error.message}`);
            }
        }
        
        // 전역 함수로 노출
        window.testConnection = testConnection;

        // === 목적 선택 ===
        function selectPurpose(purpose) {
            console.log('=== 목적 선택됨 ===');
            console.log('선택된 목적:', purpose);
            
            selectedPurpose = purpose;
            
            // 목적 이름 표시
            const purposeNames = {
                'love': '💕 사랑과 관계',
                'career': '💼 직장과 업무', 
                'daily': '🌟 오늘의 운세',
                'health': '🏥 건강과 웰빙',
                'money': '💰 재정과 돈'
            };
            
            document.getElementById('selectedPurposeName').textContent = purposeNames[purpose];
            showSection('readingType');
        }
        
        // 전역 함수로 노출
        window.selectPurpose = selectPurpose;

        // === 리딩 타입 선택 ===
        function selectReadingType(type) {
            console.log('=== 리딩 타입 선택됨 ===');
            console.log('선택된 타입:', type);
            
            selectedReadingType = type;
            
            const purposeNames = {
                'love': '💕 사랑과 관계',
                'career': '💼 직장과 업무',
                'daily': '🌟 오늘의 운세', 
                'health': '🏥 건강과 웰빙',
                'money': '💰 재정과 돈'
            };
            
            if (type === 'single') {
                document.getElementById('singlePurposeName').textContent = purposeNames[selectedPurpose];
                showSection('singleDeck');
            } else if (type === 'three') {
                document.getElementById('threePurposeName').textContent = purposeNames[selectedPurpose];
                showSection('deck');
            }
        }
        
        // 전역 함수로 노출
        window.selectReadingType = selectReadingType;

        // === 네비게이션 함수들 ===
        function goBackToPurpose() {
            selectedPurpose = null;
            selectedReadingType = null;
            showSection('purpose');
        }

        function goBackToReadingType() {
            selectedReadingType = null;
            selectedCards = [];
            selectedSingleCard = null;
            showSection('readingType');
        }

        function goBackToSingleDeck() {
            selectedSingleCard = null;
            showSection('singleDeck');
        }
        
        // 전역 함수로 노출
        window.goBackToPurpose = goBackToPurpose;
        window.goBackToReadingType = goBackToReadingType;
        window.goBackToSingleDeck = goBackToSingleDeck;

        // === 랜덤 카드 선택 ===
        function selectRandomCard() {
            console.log('=== 랜덤 카드 선택 ===');
            console.log('현재 선택된 카드 수:', selectedCards.length);
            
            if (selectedCards.length >= 3) {
                console.log('이미 3장이 선택됨');
                return;
            }

            // 이미 선택된 카드 제외
            const availableCards = allCards.filter(card => 
                !selectedCards.some(selected => selected.id === card.id)
            );

            if (availableCards.length === 0) {
                console.log('선택 가능한 카드가 없음');
                return;
            }

            // 랜덤 선택
            const randomIndex = Math.floor(Math.random() * availableCards.length);
            const selectedCard = availableCards[randomIndex];
            
            // 정방향/역방향 랜덤 결정
            selectedCard.reversed = Math.random() < 0.5;
            
            selectedCards.push(selectedCard);
            
            console.log('선택된 카드:', selectedCard.name, selectedCard.reversed ? '(역방향)' : '(정방향)');
            
            updateSelectedCardsDisplay();
        }
        
        // 전역 함수로 노출
        window.selectRandomCard = selectRandomCard;

        // === 선택된 카드 표시 업데이트 ===
        function updateSelectedCardsDisplay() {
            const countElement = document.getElementById('selectedCount');
            const listElement = document.getElementById('selectedCardsList');
            const completeBtn = document.getElementById('completeBtn');
            
            countElement.textContent = selectedCards.length;
            
            // 카드 리스트 업데이트
            listElement.innerHTML = '';
            selectedCards.forEach((card, index) => {
                const cardItem = document.createElement('div');
                cardItem.className = 'selected-card-item';
                cardItem.innerHTML = `
                    <div class="card-info">
                        <div class="card-number">${index + 1}.</div>
                        <div class="card-details">
                            <div class="card-name">${card.name}</div>
                            <div class="card-direction">${card.reversed ? '역방향' : '정방향'}</div>
                            <div class="card-type">${card.major_minor === 'major' ? '메이저 아르카나' : '마이너 아르카나'}</div>
                        </div>
                        <button class="remove-btn" onclick="removeCard(${index})">×</button>
                    </div>
                `;
                listElement.appendChild(cardItem);
            });
            
            // 완료 버튼 표시/숨김
            if (selectedCards.length === 3) {
                completeBtn.style.display = 'block';
                document.getElementById('randomSelectBtn').disabled = true;
            } else {
                completeBtn.style.display = 'none';
                document.getElementById('randomSelectBtn').disabled = false;
            }
        }

        // === 카드 제거 ===
        function removeCard(index) {
            console.log('카드 제거:', index);
            selectedCards.splice(index, 1);
            updateSelectedCardsDisplay();
        }

        // === 선택 초기화 ===
        function resetSelection() {
            console.log('선택 초기화');
            selectedCards = [];
            updateSelectedCardsDisplay();
        }

        // === 스프레드로 이동 ===
        function goToSpread() {
            console.log('=== 스프레드로 이동 ===');
            console.log('선택된 카드들:', selectedCards);
            
            if (selectedCards.length !== 3) {
                alert('3장의 카드를 모두 선택해주세요.');
                return;
            }
            
            updateSpreadDisplay();
            showSection('spread');
        }
        
        // 전역 함수로 노출
        window.removeCard = removeCard;
        window.resetSelection = resetSelection;
        window.goToSpread = goToSpread;

        // === 스프레드 화면 업데이트 ===
        function updateSpreadDisplay() {
            console.log('=== 스프레드 화면 업데이트 ===');
            
            // 디버깅 정보 업데이트
            document.getElementById('debugCardCount').textContent = selectedCards.length;
            document.getElementById('debugPurpose').textContent = selectedPurpose || '없음';
            
            // 카드 정보 업데이트
            const positions = ['past', 'present', 'future'];
            const positionNames = ['과거', '현재', '미래'];
            
            selectedCards.forEach((card, index) => {
                const position = positions[index];
                const positionName = positionNames[index];
                
                document.getElementById(`${position}CardName`).textContent = card.name;
                document.getElementById(`${position}CardDirection`).textContent = 
                    card.reversed ? '역방향' : '정방향';
                document.getElementById(`${position}CardMeaning`).textContent = 
                    `${positionName}의 ${card.reversed ? card.reversed_meaning : card.upright_meaning}`;
            });
        }

        // === 리딩 시작 ===
        async function startReading() {
            console.log('=== 리딩 시작 ===');
            console.log('선택된 카드들:', selectedCards);
            console.log('선택된 목적:', selectedPurpose);
            console.log('사용자 생년월일:', userBirthDate);
            console.log('생명수:', lifePathNumber);
            console.log('출생 계절:', birthSeason);
            
            try {
                showLoading(true);
                
                // 카드에 그룹 정보 추가
                const cardsWithGroups = selectedCards.map(card => {
                    let groupId = null;
                    
                    if (card.major_minor === 'major') {
                        // 메이저 아르카나 그룹 매핑
                        const majorGroups = {
                            0: 1, 1: 1, 2: 1,  // new_beginnings
                            6: 2, 11: 2, 14: 2, // relationships  
                            13: 3, 16: 3, 20: 3, // transformation
                            3: 4, 4: 4, 5: 4,   // material_world
                            7: 5, 8: 5, 9: 5,   // spiritual_journey
                            10: 6, 12: 6, 15: 6, 17: 6, 18: 6, 19: 6, 21: 6 // completion
                        };
                        groupId = majorGroups[card.id] || 6;
                    } else {
                        // 마이너 아르카나 수트 매핑
                        const suitGroups = {
                            'wands': 7,
                            'cups': 8, 
                            'swords': 9,
                            'pentacles': 10
                        };
                        groupId = suitGroups[card.suit] || 7;
                    }
                    
                    return { ...card, groupId };
                });
                
                console.log('그룹 정보가 추가된 카드들:', cardsWithGroups);
                
                // 목적별 개별 카드 해석 조회
                const cardReadings = await Promise.all(
                    cardsWithGroups.map(async (card) => {
                        try {
                            const { data, error } = await supabase
                                .from('tarot_purpose_readings')
                                .select('*')
                                .eq('card_id', card.id)
                                .eq('purpose_type', selectedPurpose)
                                .single();
                            
                            if (error) throw error;
                            
                            // 수치학적 개인화 적용
                            let personalizedMeaning = card.reversed ? data.reversed_meaning : data.upright_meaning;
                            let personalizedAdvice = data.advice;
                            
                            if (userBirthDate && lifePathNumber) {
                                const numerologicalInsight = await applyNumerologicalInsight(
                                    card, 
                                    selectedPurpose, 
                                    lifePathNumber, 
                                    birthSeason,
                                    card.reversed
                                );
                                
                                if (numerologicalInsight) {
                                    personalizedMeaning = numerologicalInsight.meaning;
                                    personalizedAdvice = numerologicalInsight.advice;
                                }
                            }
                            
                            return {
                                name: card.name,
                                position: ['과거', '현재', '미래'][cardsWithGroups.indexOf(card)],
                                meaning: personalizedMeaning,
                                keywords: data.keywords,
                                advice: personalizedAdvice,
                                isReversed: card.reversed,
                                numerologicalInsight: userBirthDate ? true : false
                            };
                        } catch (error) {
                            console.error('개별 카드 해석 조회 실패:', error);
                            // 폴백 해석
                            return {
                                name: card.name,
                                position: ['과거', '현재', '미래'][cardsWithGroups.indexOf(card)],
                                meaning: card.reversed ? card.reversed_meaning : card.upright_meaning,
                                keywords: card.keywords,
                                advice: '현재 상황을 잘 관찰하고 신중하게 판단하세요.',
                                isReversed: card.reversed,
                                numerologicalInsight: false
                            };
                        }
                    })
                );
                
                console.log('목적별 카드 해석:', cardReadings);
                console.log('개별 카드 의미 확인:');
                cardReadings.forEach((reading, index) => {
                    console.log(`카드 ${index + 1} (${reading.position}): ${reading.name} - ${reading.meaning.substring(0, 50)}...`);
                });
                
                // 조합 해석 동적 생성 (tarot_purpose_readings 기반, 계절 정보 포함)
                let combinationReading = generateCombinationReading(cardReadings, selectedPurpose, birthSeason);
                console.log('동적 조합 해석 생성 완료:', combinationReading);
                
                // 수치학적 조합 해석 적용
                if (userBirthDate && lifePathNumber) {
                    const numerologicalCombination = await applyNumerologicalCombination(
                        combinationReading,
                        selectedPurpose,
                        lifePathNumber,
                        birthSeason,
                        cardReadings
                    );
                    
                    if (numerologicalCombination) {
                        combinationReading = numerologicalCombination;
                    }
                }
                
                // 목적별 특화 정보 추출
                const specialInsight = getSpecialInsight(combinationReading, selectedPurpose);
                
                // 리딩 데이터 생성
                readingData = {
                    cards: cardsWithGroups,
                    purpose: selectedPurpose,
                    cardReadings: cardReadings,
                    combination: combinationReading,
                    specialInsight: specialInsight,
                    timestamp: new Date(),
                    numerologicalData: userBirthDate ? {
                        birthDate: userBirthDate,
                        lifePathNumber: lifePathNumber,
                        birthSeason: birthSeason
                    } : null
                };
                
                console.log('리딩 데이터 생성 완료:', readingData);
                
                updateResultDisplay();
                showSection('result');
                
            } catch (error) {
                console.error('리딩 생성 실패:', error);
                alert('리딩을 생성하는 중 오류가 발생했습니다.');
            } finally {
                showLoading(false);
            }
        }
        
        // 전역 함수로 노출
        window.startReading = startReading;

        // === 목적별 특화 정보 추출 ===
        function getSpecialInsight(combinationData, purposeType) {
            // 동적으로 생성된 특화 정보 반환
            switch (purposeType) {
                case 'love':
                    return combinationData.love_insights;
                case 'career':
                    return combinationData.career_guidance;
                case 'daily':
                    return combinationData.daily_focus;
                case 'health':
                    return combinationData.health_notes;
                case 'money':
                    return combinationData.money_outlook;
                default:
                    return null;
            }
        }

        // === 결과 화면 업데이트 ===
        function updateResultDisplay() {
            console.log('=== 결과 화면 업데이트 ===');
            
            // 디버깅 정보 업데이트
            document.getElementById('resultDebugCardCount').textContent = selectedCards.length;
            document.getElementById('resultDebugPurpose').textContent = selectedPurpose || '없음';
            document.getElementById('resultDebugMeanings').textContent = readingData.cardReadings.length;
            
            // 수치학적 정보 표시
            let numerologicalInfo = '';
            if (readingData.numerologicalData) {
                const birthDateStr = readingData.numerologicalData.birthDate.toLocaleDateString('ko-KR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                numerologicalInfo = `
                    <div class="numerological-info">
                        <h4>🔢 수치학적 개인화 정보</h4>
                        <p><strong>생년월일:</strong> ${birthDateStr}</p>
                        <p><strong>생명수:</strong> ${readingData.numerologicalData.lifePathNumber}</p>
                        <p><strong>출생 계절:</strong> ${readingData.numerologicalData.birthSeason.emoji} ${readingData.numerologicalData.birthSeason.name}</p>
                        <p class="numerological-note">💡 위의 해석은 수치학적 관점을 바탕으로 개인화되었습니다.</p>
                    </div>
                `;
            }
            
            // 해석 결과 표시
            document.getElementById('overallMeaning').innerHTML = `
                <div class="reading-sections">
                    <div class="reading-section">
                        <h4>📖 과거</h4>
                        <p>${readingData.combination.past_meaning}</p>
                    </div>
                    <div class="reading-section">
                        <h4>🎯 현재</h4>
                        <p>${readingData.combination.present_meaning}</p>
                    </div>
                    <div class="reading-section">
                        <h4>🔮 미래</h4>
                        <p>${readingData.combination.future_meaning}</p>
                    </div>
                    <div class="reading-section full-width">
                        <h4>🌟 전체적인 해석</h4>
                        <p>${readingData.combination.overall_meaning}</p>
                    </div>
                    ${readingData.specialInsight ? `
                        <div class="reading-section full-width purpose-specific">
                            <h4>${getPurposeSpecificTitle(selectedPurpose)}</h4>
                            <p>${readingData.specialInsight}</p>
                        </div>
                    ` : ''}
                </div>
            `;
            
            document.getElementById('advice').textContent = readingData.combination.advice;
            
            // 카드 상세 정보 표시
            const cardsList = document.getElementById('resultCardsList');
            cardsList.innerHTML = '';
            
            readingData.cardReadings.forEach((cardReading, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card-detail';
                cardDiv.innerHTML = `
                    <h4>${cardReading.position}: ${cardReading.name}</h4>
                    <p class="card-direction">${cardReading.isReversed ? '역방향' : '정방향'}</p>
                    <p class="card-meaning">${cardReading.meaning}</p>
                    <p class="card-keywords">키워드: ${cardReading.keywords}</p>
                    <p class="card-advice">조언: ${cardReading.advice}</p>
                `;
                cardsList.appendChild(cardDiv);
            });
        }

        // === 목적별 특화 제목 ===
        function getPurposeSpecificTitle(purposeType) {
            const titles = {
                'love': '💕 연애 특별 조언',
                'career': '💼 직장 가이드',
                'daily': '☀️ 오늘의 집중점',
                'health': '🌿 건강 주의사항',
                'money': '💰 금전 전망'
            };
            return titles[purposeType] || '특별 조언';
        }

                // === 수치학적 개인화 함수들 ===
        // NumerologyService 인스턴스 생성
        const numerologyService = new NumerologyService();
        
        async function applyNumerologicalInsight(card, purpose, lifePathNumber, birthSeason, isReversed) {
            try {
                return await numerologyService.applyNumerologicalInsight(card, purpose, lifePathNumber, birthSeason, isReversed);
            } catch (error) {
                console.error('수치학적 해석 적용 실패:', error);
                return null;
            }
        }

        async function applyNumerologicalCombination(combinationReading, purpose, lifePathNumber, birthSeason, cardReadings) {
            try {
                return await numerologyService.applyNumerologicalCombination(combinationReading, purpose, lifePathNumber, birthSeason, cardReadings);
            } catch (error) {
                console.error('수치학적 조합 해석 적용 실패:', error);
                return null;
            }
        }

        // generateNumerologicalAdvice 함수는 제거됨 - 데이터베이스에서 조언을 가져옴

        // === 조합 해석 동적 생성 함수 ===
        function generateCombinationReading(cardReadings, purpose, birthSeason = null) {
            const positions = ['과거', '현재', '미래'];
            
            console.log('generateCombinationReading 호출됨:');
            console.log('과거 카드:', cardReadings[0].name, '의미:', cardReadings[0].meaning.substring(0, 30) + '...');
            console.log('현재 카드:', cardReadings[1].name, '의미:', cardReadings[1].meaning.substring(0, 30) + '...');
            console.log('미래 카드:', cardReadings[2].name, '의미:', cardReadings[2].meaning.substring(0, 30) + '...');
            
            // 기본 조합 해석 생성
            const combinationReading = {
                past_meaning: cardReadings[0].meaning,
                present_meaning: cardReadings[1].meaning,
                future_meaning: cardReadings[2].meaning,
                overall_meaning: generateOverallMeaning(cardReadings, purpose, birthSeason),
                advice: generateAdvice(cardReadings, purpose)
            };
            
            // 목적별 특화 정보 동적 생성
            const specialInsights = generateSpecialInsights(cardReadings, purpose);
            Object.assign(combinationReading, specialInsights);
            
            return combinationReading;
        }
        
        // === 목적별 특화 정보 동적 생성 ===
        function generateSpecialInsights(cardReadings, purpose) {
            const insights = {};
            
            switch (purpose) {
                case 'love':
                    insights.love_insights = generateLoveInsights(cardReadings);
                    break;
                case 'career':
                    insights.career_guidance = generateCareerGuidance(cardReadings);
                    break;
                case 'daily':
                    insights.daily_focus = generateDailyFocus(cardReadings);
                    break;
                case 'health':
                    insights.health_notes = generateHealthNotes(cardReadings);
                    break;
                case 'money':
                    insights.money_outlook = generateMoneyOutlook(cardReadings);
                    break;
            }
            
            return insights;
        }
        
        // === 목적별 특화 해석 생성 함수들 ===
        function generateLoveInsights(cardReadings) {
            const reversedCount = cardReadings.filter(card => card.isReversed).length;
            const cardMeanings = cardReadings.map(card => card.meaning);
            
            // 연애 관련 요소 분석
            const loveThemes = analyzeLoveThemes(cardMeanings);
            const relationshipDynamics = analyzeRelationshipDynamics(cardMeanings);
            
            if (reversedCount >= 2) {
                const challenges = analyzeLoveChallenges(cardMeanings);
                return `현재 연애 상황에서 ${challenges}이 있을 수 있습니다. 하지만 ${loveThemes}의 관점에서 바라보면 ${relationshipDynamics}의 기회로 발전시킬 수 있습니다.`;
            } else if (reversedCount === 1) {
                const balanceNeeds = analyzeLoveBalance(cardMeanings);
                return `연애에서 ${balanceNeeds}의 균형을 찾는 것이 중요합니다. ${loveThemes}의 에너지를 통해 ${relationshipDynamics}를 발전시켜 나가세요.`;
            } else {
                const positiveAspects = analyzeLovePositives(cardMeanings);
                return `연애에 ${positiveAspects}의 에너지가 가득합니다. ${loveThemes}의 조합이 ${relationshipDynamics}의 성장을 이끌어낼 것입니다.`;
            }
        }
        
        // 연애 테마 분석
        function analyzeLoveThemes(meanings) {
            const themes = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('사랑') || meaning.includes('연애')) {
                    themes.push('진정한 사랑');
                } else if (meaning.includes('관계') || meaning.includes('소통')) {
                    themes.push('깊은 소통');
                } else if (meaning.includes('신뢰') || meaning.includes('믿음')) {
                    themes.push('상호 신뢰');
                } else if (meaning.includes('성장') || meaning.includes('발전')) {
                    themes.push('함께 성장');
                }
            });
            
            return themes.length > 0 ? themes[0] : '사랑의 성장';
        }
        
        // 관계 역학 분석
        function analyzeRelationshipDynamics(meanings) {
            const dynamics = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('소통') || meaning.includes('이해')) {
                    dynamics.push('더 나은 소통');
                } else if (meaning.includes('조화') || meaning.includes('균형')) {
                    dynamics.push('관계의 조화');
                } else if (meaning.includes('성장') || meaning.includes('발전')) {
                    dynamics.push('함께하는 성장');
                } else if (meaning.includes('신뢰') || meaning.includes('믿음')) {
                    dynamics.push('깊어지는 신뢰');
                }
            });
            
            return dynamics.length > 0 ? dynamics[0] : '관계의 발전';
        }
        
        // 연애 어려움 분석
        function analyzeLoveChallenges(meanings) {
            const challenges = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('오해') || meaning.includes('갈등')) {
                    challenges.push('소통의 어려움');
                } else if (meaning.includes('불안') || meaning.includes('의심')) {
                    challenges.push('신뢰의 문제');
                } else if (meaning.includes('거리') || meaning.includes('소원')) {
                    challenges.push('감정적 거리감');
                }
            });
            
            return challenges.length > 0 ? challenges[0] : '관계의 어려움';
        }
        
        // 연애 균형 분석
        function analyzeLoveBalance(meanings) {
            const balances = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('개인') || meaning.includes('관계')) {
                    balances.push('개인과 관계');
                } else if (meaning.includes('감정') || meaning.includes('이성')) {
                    balances.push('감정과 이성');
                } else if (meaning.includes('과거') || meaning.includes('미래')) {
                    balances.push('과거와 미래');
                }
            });
            
            return balances.length > 0 ? balances[0] : '다양한 측면';
        }
        
        // 연애 긍정 요소 분석
        function analyzeLovePositives(meanings) {
            const positives = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('사랑') || meaning.includes('애정')) {
                    positives.push('깊은 사랑');
                } else if (meaning.includes('성장') || meaning.includes('발전')) {
                    positives.push('함께 성장');
                } else if (meaning.includes('조화') || meaning.includes('평온')) {
                    positives.push('관계의 조화');
                }
            });
            
            return positives.length > 0 ? positives[0] : '사랑의 에너지';
        }
        
        function generateCareerGuidance(cardReadings) {
            const reversedCount = cardReadings.filter(card => card.isReversed).length;
            const keywords = cardReadings.map(card => card.keywords).join(', ');
            
            if (reversedCount >= 2) {
                return `직장에서 도전적인 상황이 있을 수 있습니다. ${keywords}의 에너지를 통해 문제를 해결하고 성장의 기회로 활용하세요.`;
            } else if (reversedCount === 1) {
                return `업무에서 일부 어려움이 있지만, 전반적으로는 발전의 기회입니다. ${keywords}의 조합을 통해 커리어를 발전시켜 나가세요.`;
            } else {
                return `직장에서 매우 긍정적인 발전이 예상됩니다. ${keywords}의 조합이 성공과 성장을 이끌어낼 것입니다.`;
            }
        }
        
        function generateDailyFocus(cardReadings) {
            const reversedCount = cardReadings.filter(card => card.isReversed).length;
            const cardMeanings = cardReadings.map(card => card.meaning);
            
            // 카드들의 의미를 분석하여 자연스러운 문장 생성
            let focusMessage = '';
            
            if (reversedCount >= 2) {
                // 어려움이 있는 상황
                const challenges = analyzeChallenges(cardMeanings);
                const growthOpportunities = analyzeGrowthOpportunities(cardMeanings);
                
                focusMessage = `오늘은 ${challenges}에 주의해야 할 날입니다. 하지만 이는 ${growthOpportunities}의 기회이기도 합니다. 차분히 상황을 파악하고 신중하게 대응하세요.`;
            } else if (reversedCount === 1) {
                // 균형이 필요한 상황
                const balanceAspects = analyzeBalanceAspects(cardMeanings);
                const positiveElements = analyzePositiveElements(cardMeanings);
                
                focusMessage = `오늘은 ${balanceAspects}의 균형을 찾는 것이 중요합니다. ${positiveElements}의 에너지를 활용하여 하루를 의미 있게 보내세요.`;
            } else {
                // 긍정적인 상황
                const positiveThemes = analyzePositiveThemes(cardMeanings);
                const opportunities = analyzeOpportunities(cardMeanings);
                
                focusMessage = `오늘은 ${positiveThemes}의 에너지가 가득한 날입니다. ${opportunities}의 기회를 놓치지 마시고 적극적으로 활용하세요.`;
            }
            
            return focusMessage;
        }
        
        // 어려움 분석 함수
        function analyzeChallenges(meanings) {
            const challenges = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('어려움') || meaning.includes('도전') || meaning.includes('갈등')) {
                    challenges.push('현재 상황의 어려움');
                } else if (meaning.includes('불안') || meaning.includes('우려')) {
                    challenges.push('내면의 불안감');
                } else if (meaning.includes('변화') || meaning.includes('전환')) {
                    challenges.push('예상치 못한 변화');
                }
            });
            
            return challenges.length > 0 ? challenges[0] : '일시적인 어려움';
        }
        
        // 성장 기회 분석 함수
        function analyzeGrowthOpportunities(meanings) {
            const opportunities = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('학습') || meaning.includes('성장')) {
                    opportunities.push('개인적 성장');
                } else if (meaning.includes('인내') || meaning.includes('지혜')) {
                    opportunities.push('내면의 성숙');
                } else if (meaning.includes('변화') || meaning.includes('새로운')) {
                    opportunities.push('새로운 가능성');
                }
            });
            
            return opportunities.length > 0 ? opportunities[0] : '개인적 발전';
        }
        
        // 균형 요소 분석 함수
        function analyzeBalanceAspects(meanings) {
            const aspects = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('감정') || meaning.includes('직관')) {
                    aspects.push('감정과 이성');
                } else if (meaning.includes('과거') || meaning.includes('미래')) {
                    aspects.push('과거와 미래');
                } else if (meaning.includes('개인') || meaning.includes('관계')) {
                    aspects.push('개인과 관계');
                } else if (meaning.includes('물질') || meaning.includes('정신')) {
                    aspects.push('물질과 정신');
                }
            });
            
            return aspects.length > 0 ? aspects[0] : '다양한 측면';
        }
        
        // 긍정적 요소 분석 함수
        function analyzePositiveElements(meanings) {
            const elements = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('창의') || meaning.includes('혁신')) {
                    elements.push('창의적 사고');
                } else if (meaning.includes('협력') || meaning.includes('조화')) {
                    elements.push('협력과 조화');
                } else if (meaning.includes('성장') || meaning.includes('발전')) {
                    elements.push('지속적 성장');
                } else if (meaning.includes('안정') || meaning.includes('평온')) {
                    elements.push('내면의 평온');
                }
            });
            
            return elements.length > 0 ? elements[0] : '긍정적 에너지';
        }
        
        // 긍정적 테마 분석 함수
        function analyzePositiveThemes(meanings) {
            const themes = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('성공') || meaning.includes('성취')) {
                    themes.push('성공과 성취');
                } else if (meaning.includes('사랑') || meaning.includes('관계')) {
                    themes.push('사랑과 관계');
                } else if (meaning.includes('창의') || meaning.includes('혁신')) {
                    themes.push('창의와 혁신');
                } else if (meaning.includes('지혜') || meaning.includes('통찰')) {
                    themes.push('지혜와 통찰');
                } else if (meaning.includes('안정') || meaning.includes('평온')) {
                    themes.push('안정과 평온');
                }
            });
            
            return themes.length > 0 ? themes[0] : '긍정과 희망';
        }
        
        // 기회 분석 함수
        function analyzeOpportunities(meanings) {
            const opportunities = [];
            
            meanings.forEach(meaning => {
                if (meaning.includes('새로운') || meaning.includes('시작')) {
                    opportunities.push('새로운 시작');
                } else if (meaning.includes('발전') || meaning.includes('성장')) {
                    opportunities.push('개인적 발전');
                } else if (meaning.includes('협력') || meaning.includes('소통')) {
                    opportunities.push('협력과 소통');
                } else if (meaning.includes('창의') || meaning.includes('표현')) {
                    opportunities.push('창의적 표현');
                }
            });
            
            return opportunities.length > 0 ? opportunities[0] : '좋은 기회';
        }
        
        function generateHealthNotes(cardReadings) {
            const keywords = cardReadings.map(card => card.keywords).join(', ');
            const reversedCount = cardReadings.filter(card => card.isReversed).length;
            
            if (reversedCount >= 2) {
                return `건강에 주의가 필요한 시기입니다. ${keywords}의 에너지를 통해 건강 관리의 중요성을 인식하고 적극적으로 대응하세요.`;
            } else if (reversedCount === 1) {
                return `건강에 일부 주의가 필요하지만, 전반적으로는 양호합니다. ${keywords}의 조합을 통해 건강한 라이프스타일을 유지하세요.`;
            } else {
                return `건강에 매우 긍정적인 에너지가 흐르고 있습니다. ${keywords}의 조합이 건강과 웰빙을 증진시킬 것입니다.`;
            }
        }
        
        function generateMoneyOutlook(cardReadings) {
            const keywords = cardReadings.map(card => card.keywords).join(', ');
            const reversedCount = cardReadings.filter(card => card.isReversed).length;
            
            if (reversedCount >= 2) {
                return `재정 상황에서 주의가 필요한 시기입니다. ${keywords}의 에너지를 통해 재정 관리를 신중하게 하고 위험을 피하세요.`;
            } else if (reversedCount === 1) {
                return `재정에 일부 어려움이 있지만, 전반적으로는 안정적입니다. ${keywords}의 조합을 통해 현명한 재정 결정을 내리세요.`;
            } else {
                return `재정에 매우 긍정적인 전망이 있습니다. ${keywords}의 조합이 재정적 성공과 안정을 가져올 것입니다.`;
            }
        }

        // === 해석 생성 함수들 ===
        function generateOverallMeaning(cardMeanings, purpose, birthSeason = null) {
            const purposeNames = {
                'love': '사랑과 관계',
                'career': '직장과 업무',
                'daily': '오늘의 운세',
                'health': '건강과 웰빙',
                'money': '재정과 돈'
            };
            
            const purposeName = purposeNames[purpose] || '일반적인';
            const cardNames = cardMeanings.map(card => card.name);
            const keywords = cardMeanings.map(card => card.keywords).join(', ');
            
            let overallMeaning = `${purposeName} 측면에서 ${cardNames[0]}, ${cardNames[1]}, ${cardNames[2]}의 조합은 ${keywords}의 에너지를 나타냅니다. 과거의 경험이 현재의 선택에 영향을 미치고, 미래의 방향성을 제시하고 있습니다.`;
            
            // 계절별 컨텍스트 추가 (전체 조합 해석에만)
            if (birthSeason && birthSeason.name) {
                const seasonContexts = {
                    '봄': '봄의 새로운 시작과 성장의 에너지가 이 조합에 활력을 더하고 있습니다.',
                    '여름': '여름의 활력과 열정이 넘치는 에너지가 이 조합에 힘을 실어주고 있습니다.',
                    '가을': '가을의 수확과 성숙의 에너지가 이 조합에 깊이를 더하고 있습니다.',
                    '겨울': '겨울의 내면의 성찰과 준비의 에너지가 이 조합에 지혜를 더하고 있습니다.'
                };
                
                const seasonContext = seasonContexts[birthSeason.name] || '';
                if (seasonContext) {
                    overallMeaning += ` ${seasonContext}`;
                }
            }
            
            return overallMeaning;
        }

        function generateAdvice(cardMeanings, purpose) {
            const reversedCards = cardMeanings.filter(card => card.isReversed);
            const uprightCards = cardMeanings.filter(card => !card.isReversed);
            
            if (reversedCards.length > 1) {
                return '역방향 카드가 많아 현재 어려운 시기를 겪고 있을 수 있습니다. 인내심을 가지고 상황을 관찰하세요.';
            } else if (uprightCards.length > 1) {
                return '정방향 카드가 많아 긍정적인 에너지가 흐르고 있습니다. 자신의 직감을 믿고 행동하세요.';
            } else {
                return '균형 잡힌 카드 배치입니다. 현재 상황을 객관적으로 분석하고 신중하게 판단하세요.';
            }
        }

        // === 네비게이션 함수들 ===
        function goToSelection() {
            showSection('deck');
        }

        // === 한 장 카드 선택 ===
        function selectSingleRandomCard() {
            console.log('=== 한 장 랜덤 카드 선택 ===');
            
            if (allCards.length === 0) {
                alert('카드 데이터를 불러오는 중입니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            // 랜덤 선택
            const randomIndex = Math.floor(Math.random() * allCards.length);
            const selectedCard = allCards[randomIndex];
            
            // 정방향/역방향 랜덤 결정
            selectedCard.reversed = Math.random() < 0.5;
            
            selectedSingleCard = selectedCard;
            
            console.log('선택된 카드:', selectedCard.name, selectedCard.reversed ? '(역방향)' : '(정방향)');
            
            updateSingleCardDisplay();
        }
        
        // 전역 함수로 노출
        window.selectSingleRandomCard = selectSingleRandomCard;

        // === 한 장 카드 표시 업데이트 ===
        function updateSingleCardDisplay() {
            const card = selectedSingleCard;
            const displayElement = document.getElementById('singleSelectedCard');
            
            displayElement.innerHTML = `
                <div class="single-card-visual">
                    <div class="card-placeholder ${card.reversed ? 'reversed' : ''}" style="
                        width: 200px;
                        height: 320px;
                        background: linear-gradient(135deg, #2c3e50, #34495e);
                        border: 3px solid #ecf0f1;
                        border-radius: 15px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        text-align: center;
                        padding: 20px;
                        box-shadow: 0 8px 16px rgba(0,0,0,0.3);
                        margin: 0 auto 20px;
                        transform: ${card.reversed ? 'rotate(180deg)' : 'rotate(0deg)'};
                    ">
                        <div style="color: #ecf0f1; font-size: 16px; font-weight: bold; margin-bottom: 10px;">
                            ${card.name}
                        </div>
                        <div style="color: #ecf0f1; font-size: 12px; opacity: 0.8;">
                            ${card.suit ? `${card.suit}` : ''}
                        </div>
                        <div style="color: #ecf0f1; font-size: 10px; opacity: 0.6; margin-top: 10px;">
                            ${card.reversed ? 'Reversed' : 'Upright'}
                        </div>
                    </div>
                </div>
                <div class="single-card-details">
                    <h4>${card.name}</h4>
                    <p class="card-type">${card.major_minor === 'major' ? '메이저 아르카나' : '마이너 아르카나'}</p>
                    <p class="card-direction ${card.reversed ? 'reversed' : 'upright'}">
                        ${card.reversed ? '역방향' : '정방향'}
                    </p>
                </div>
            `;
            
            document.getElementById('singleCardDisplay').style.display = 'block';
        }

        // === 한 장 선택 초기화 ===
        function resetSingleSelection() {
            console.log('한 장 선택 초기화');
            selectedSingleCard = null;
            document.getElementById('singleCardDisplay').style.display = 'none';
        }
        
        // 전역 함수로 노출
        window.resetSingleSelection = resetSingleSelection;

        // === 한 장 리딩 시작 ===
        async function startSingleReading() {
            console.log('=== 한 장 리딩 시작 ===');
            console.log('선택된 카드:', selectedSingleCard);
            console.log('선택된 목적:', selectedPurpose);
            console.log('사용자 생년월일:', userBirthDate);
            console.log('생명수:', lifePathNumber);
            console.log('출생 계절:', birthSeason);
            
            if (!selectedSingleCard) {
                alert('카드를 먼저 선택해주세요.');
                return;
            }
            
            try {
                showLoading(true);
                
                // 카드에 그룹 정보 추가
                const cardWithGroup = addGroupInfoToCard(selectedSingleCard);
                
                // 목적별 개별 카드 해석 조회
                let cardReading = null;
                try {
                    const { data, error } = await supabase
                        .from('tarot_purpose_readings')
                        .select('upright_meaning, reversed_meaning, keywords, advice')
                        .eq('card_id', cardWithGroup.id)
                        .eq('purpose_type', selectedPurpose)
                        .single();
                    
                    if (error) throw error;
                    cardReading = data;
                    console.log('목적별 카드 해석 조회 성공:', cardReading);
                } catch (error) {
                    console.error('목적별 카드 해석 조회 실패:', error);
                    // 폴백 해석
                    cardReading = {
                        upright_meaning: cardWithGroup.upright_meaning,
                        reversed_meaning: cardWithGroup.reversed_meaning,
                        keywords: cardWithGroup.keywords,
                        advice: '현재 상황을 잘 관찰하고 신중하게 판단하세요.'
                    };
                }
                
                // 수치학적 개인화 적용
                let personalizedMeaning = cardWithGroup.reversed ? cardReading.reversed_meaning : cardReading.upright_meaning;
                let personalizedAdvice = cardReading.advice;
                
                if (userBirthDate && lifePathNumber) {
                    const numerologicalInsight = await applyNumerologicalInsight(
                        cardWithGroup, 
                        selectedPurpose, 
                        lifePathNumber, 
                        birthSeason,
                        cardWithGroup.reversed
                    );
                    
                    if (numerologicalInsight) {
                        // 안전 병합: 누락 시 원래 값 유지
                        personalizedMeaning = numerologicalInsight.meaning || personalizedMeaning;
                        // 조언은 데이터베이스 원본 유지 (수치학적 조언으로 덮어쓰지 않음)
                        // personalizedAdvice = numerologicalInsight.advice || personalizedAdvice;
                    }
                }
                
                // 한 장 리딩 특화 해석 생성
                const singleReadingData = generateSingleReadingInsight(
                    { ...cardReading, upright_meaning: personalizedMeaning, advice: personalizedAdvice }, 
                    selectedPurpose, 
                    cardWithGroup.reversed
                );
                
                // 리딩 데이터 생성
                readingData = {
                    type: 'single',
                    card: cardWithGroup,
                    purpose: selectedPurpose,
                    cardReading: { ...cardReading, upright_meaning: personalizedMeaning, advice: personalizedAdvice },
                    singleInsight: singleReadingData,
                    timestamp: new Date(),
                    numerologicalData: userBirthDate ? {
                        birthDate: userBirthDate,
                        lifePathNumber: lifePathNumber,
                        birthSeason: birthSeason
                    } : null
                };
                
                console.log('한 장 리딩 데이터 생성 완료:', readingData);
                
                updateSingleResultDisplay();
                showSection('singleResult');
                
            } catch (error) {
                console.error('한 장 리딩 생성 실패:', error);
                alert('리딩을 생성하는 중 오류가 발생했습니다.');
            } finally {
                showLoading(false);
            }
        }
        
        // 전역 함수로 노출
        window.startSingleReading = startSingleReading;

        // === 카드에 그룹 정보 추가 ===
        function addGroupInfoToCard(card) {
            let groupId = null;
            let groupName = null;
            
            if (card.major_minor === 'major') {
                const majorGroups = {
                    0: { id: 1, name: 'new_beginnings' },
                    1: { id: 1, name: 'new_beginnings' },
                    2: { id: 1, name: 'new_beginnings' },
                    6: { id: 2, name: 'relationships' },
                    11: { id: 2, name: 'relationships' },
                    14: { id: 2, name: 'relationships' },
                    13: { id: 3, name: 'transformation' },
                    16: { id: 3, name: 'transformation' },
                    20: { id: 3, name: 'transformation' },
                    3: { id: 4, name: 'material_world' },
                    4: { id: 4, name: 'material_world' },
                    5: { id: 4, name: 'material_world' },
                    7: { id: 5, name: 'spiritual_journey' },
                    8: { id: 5, name: 'spiritual_journey' },
                    9: { id: 5, name: 'spiritual_journey' },
                    10: { id: 6, name: 'completion' },
                    12: { id: 6, name: 'completion' },
                    15: { id: 6, name: 'completion' },
                    17: { id: 6, name: 'completion' },
                    18: { id: 6, name: 'completion' },
                    19: { id: 6, name: 'completion' },
                    21: { id: 6, name: 'completion' }
                };
                const group = majorGroups[card.id] || { id: 6, name: 'completion' };
                groupId = group.id;
                groupName = group.name;
            } else {
                const suitGroups = {
                    'wands': { id: 7, name: 'wands' },
                    'cups': { id: 8, name: 'cups' },
                    'swords': { id: 9, name: 'swords' },
                    'pentacles': { id: 10, name: 'pentacles' }
                };
                const group = suitGroups[card.suit] || { id: 7, name: 'wands' };
                groupId = group.id;
                groupName = group.name;
            }
            
            return { ...card, groupId, groupName };
        }

        // === 한 장 리딩 특화 해석 생성 ===
        function generateSingleReadingInsight(cardReading, purposeType, isReversed) {
            const meaning = isReversed ? cardReading.reversed_meaning : cardReading.upright_meaning;
            
            // 목적별 특화 해석 생성
            const purposeInsights = {
                love: {
                    title: '💕 연애 특별 조언',
                    focus: generateLoveFocus(meaning, isReversed),
                    action: generateLoveAction(meaning, isReversed),
                    avoid: generateLoveAvoid(meaning, isReversed)
                },
                career: {
                    title: '💼 직장 가이드',
                    focus: generateCareerFocus(meaning, isReversed),
                    action: generateCareerAction(meaning, isReversed),
                    avoid: generateCareerAvoid(meaning, isReversed)
                },
                daily: {
                    title: '☀️ 오늘의 집중점',
                    focus: generateSingleDailyFocus(meaning, isReversed),
                    action: generateDailyAction(meaning, isReversed),
                    avoid: generateDailyAvoid(meaning, isReversed)
                },
                health: {
                    title: '🌿 건강 주의사항',
                    focus: generateHealthFocus(meaning, isReversed),
                    action: generateHealthAction(meaning, isReversed),
                    avoid: generateHealthAvoid(meaning, isReversed)
                },
                money: {
                    title: '💰 금전 전망',
                    focus: generateMoneyFocus(meaning, isReversed),
                    action: generateMoneyAction(meaning, isReversed),
                    avoid: generateMoneyAvoid(meaning, isReversed)
                }
            };
            
            return purposeInsights[purposeType] || purposeInsights.daily;
        }
        
        // === 목적별 핵심 메시지 생성 함수들 ===
        function generateLoveFocus(meaning, isReversed) {
            if (isReversed) {
                return '현재 연애 상황에서 소통과 이해가 부족한 상태입니다. 진정한 감정을 표현하는 것이 중요합니다.';
            }
            return '사랑과 관계에서 진정성과 소통이 핵심입니다. 상대방을 이해하고 조화로운 관계를 만들어가세요.';
        }
        
        function generateCareerFocus(meaning, isReversed) {
            if (isReversed) {
                return '업무에서 새로운 접근이 필요한 시기입니다. 기존 방식에 얽매이지 말고 혁신을 추구하세요.';
            }
            return '직장에서 전문성과 리더십을 발휘할 수 있는 기회입니다. 자신의 능력을 믿고 도전하세요.';
        }
        
        function generateSingleDailyFocus(meaning, isReversed) {
            if (isReversed) {
                return '오늘은 내면의 성찰과 관찰이 중요한 날입니다. 서두르지 말고 상황을 차분히 파악하세요.';
            }
            return '오늘은 활발한 활동과 새로운 경험을 추구하기 좋은 날입니다. 에너지를 활용하여 성장하세요.';
        }
        
        function generateHealthFocus(meaning, isReversed) {
            if (isReversed) {
                return '건강 관리에서 균형과 휴식이 중요한 시기입니다. 스트레스를 줄이고 충분한 휴식을 취하세요.';
            }
            return '건강한 라이프스타일을 유지하기 좋은 시기입니다. 활발한 활동과 규칙적인 생활을 추구하세요.';
        }
        
        function generateMoneyFocus(meaning, isReversed) {
            if (isReversed) {
                return '재정 관리에서 신중함이 필요한 시기입니다. 현재 상황을 점검하고 안정적인 계획을 세우세요.';
            }
            return '재정적 성장과 새로운 기회를 찾기 좋은 시기입니다. 적극적으로 투자 기회를 탐색하세요.';
        }
        
        // === 목적별 액션 생성 함수들 ===
        function generateLoveAction(meaning, isReversed) {
            if (isReversed) {
                return '상대방과의 소통을 개선하고 진정한 감정을 표현하세요.';
            }
            return '사랑하는 마음을 솔직하게 표현하고 상대방을 이해하려 노력하세요.';
        }
        
        function generateLoveAvoid(meaning, isReversed) {
            if (isReversed) {
                return '감정을 숨기거나 상대방을 의심하지 마세요.';
            }
            return '과도한 기대나 소유욕을 버리고 자유로운 사랑을 추구하세요.';
        }
        
        function generateCareerAction(meaning, isReversed) {
            if (isReversed) {
                return '현재 상황을 객관적으로 분석하고 새로운 접근 방법을 모색하세요.';
            }
            return '자신의 능력을 믿고 적극적으로 업무에 임하세요.';
        }
        
        function generateCareerAvoid(meaning, isReversed) {
            if (isReversed) {
                return '성급한 결정이나 포기를 하지 마세요.';
            }
            return '과도한 자신감이나 독단적인 행동을 피하세요.';
        }
        
        function generateDailyAction(meaning, isReversed) {
            if (isReversed) {
                return '오늘은 차분히 상황을 관찰하고 내면의 목소리를 들어보세요. 창조적인 활동보다는 성찰의 시간을 가지세요.';
            }
            return '오늘의 에너지를 활용하여 새로운 경험을 시도해보세요. 창조적이고 활발한 활동을 추구하세요.';
        }
        
        function generateDailyAvoid(meaning, isReversed) {
            if (isReversed) {
                return '부정적인 생각이나 성급한 행동을 피하세요.';
            }
            return '과도한 활동이나 무리한 계획을 세우지 마세요.';
        }
        
        function generateHealthAction(meaning, isReversed) {
            if (isReversed) {
                return '스트레스를 줄이고 충분한 휴식을 취하세요.';
            }
            return '활발한 활동과 건강한 습관을 유지하세요.';
        }
        
        function generateHealthAvoid(meaning, isReversed) {
            if (isReversed) {
                return '과도한 운동이나 스트레스가 많은 활동을 피하세요.';
            }
            return '무리한 운동이나 불규칙한 생활을 하지 마세요.';
        }
        
        function generateMoneyAction(meaning, isReversed) {
            if (isReversed) {
                return '재정 상태를 점검하고 신중한 투자 결정을 내리세요.';
            }
            return '새로운 투자 기회를 탐색하고 재정 계획을 세우세요.';
        }
        
        function generateMoneyAvoid(meaning, isReversed) {
            if (isReversed) {
                return '성급한 투자나 과도한 지출을 피하세요.';
            }
            return '과도한 위험을 감수하거나 무계획한 지출을 하지 마세요.';
        }

        // === 한 장 리딩 결과 화면 업데이트 ===
        function updateSingleResultDisplay() {
            console.log('=== 한 장 리딩 결과 화면 업데이트 ===');
            
            const card = readingData.card;
            const cardReading = readingData.cardReading;
            const insight = readingData.singleInsight;
            
            // 카드 정보 표시
            document.getElementById('singleResultCardName').textContent = card.name;
            document.getElementById('singleResultCardType').textContent = 
                card.major_minor === 'major' ? '메이저 아르카나' : '마이너 아르카나';
            document.getElementById('singleResultCardDirection').textContent = 
                card.reversed ? '역방향' : '정방향';
            
            // 카드 이미지 표시
            document.getElementById('singleResultCardDisplay').innerHTML = `
                <div class="card-placeholder ${card.reversed ? 'reversed' : ''}" style="
                    width: 250px;
                    height: 400px;
                    background: linear-gradient(135deg, #2c3e50, #34495e);
                    border: 3px solid #ecf0f1;
                    border-radius: 15px;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    padding: 20px;
                    box-shadow: 0 8px 16px rgba(0,0,0,0.3);
                    margin: 0 auto;
                    transform: ${card.reversed ? 'rotate(180deg)' : 'rotate(0deg)'};
                ">
                    <div style="color: #ecf0f1; font-size: 18px; font-weight: bold; margin-bottom: 15px;">
                        ${card.name}
                    </div>
                    <div style="color: #ecf0f1; font-size: 14px; opacity: 0.8;">
                        ${card.suit ? `${card.suit}` : ''}
                    </div>
                    <div style="color: #ecf0f1; font-size: 12px; opacity: 0.6; margin-top: 15px;">
                        ${card.reversed ? 'Reversed' : 'Upright'}
                    </div>
                </div>
            `;
            
            // 해석 내용 표시 (이미 수치학적 개인화가 적용된 의미 사용)
            const meaning = card.reversed ? cardReading.reversed_meaning : cardReading.upright_meaning;
            document.getElementById('singleCoreMeaning').textContent = meaning;
            document.getElementById('singleDetailedMeaning').textContent = meaning;
            document.getElementById('singleKeywords').textContent = cardReading.keywords;
            document.getElementById('singleAdvice').textContent = cardReading.advice;
            
            // 목적별 특화 정보
            document.getElementById('singleSpecialTitle').textContent = insight.title;
            document.getElementById('singleSpecialInsight').innerHTML = `
                <p><strong>핵심 메시지:</strong> ${insight.focus}</p>
                <p><strong>오늘의 할일:</strong> ${insight.action}</p>
                <p><strong>주의사항:</strong> ${insight.avoid}</p>
            `;
        }

        function startOver() {
            selectedPurpose = null;
            selectedReadingType = null;
            selectedCards = [];
            selectedSingleCard = null;
            readingData = null;
            userBirthDate = null;
            lifePathNumber = null;
            birthSeason = null;
            showSection('birthDateInput');
        }
    </script>
</body>
</html>